#+TITLE:     My Emacs Configuration
#+AUTHOR:    Jesse Haubrich
#+EMAIL:     jesse.haubrich@protonmail.com
#+DATE:      2015-06-10

This was borrowed heavily from [[https://github.com/joedicastro/dotfiles/tree/master/emacs][Joe's config]]. Thank you, Joe.

* Prerequisites
- [[http://geoff.greer.fm/2011/12/27/the-silver-searcher-better-than-ack][Ag (aka "The Silver Searcher")]]
- [[http://git-scm.com/][git]]
- [[http://curl.haxx.se/][curl]], [[http://www.gnu.org/software/wget/][wget]], [[http://www.openssl.org/][OpenSSL]] or [[http://www.gnu.org/software/gnutls/][GnuTLS]] for twittering-mode
- [[http://www.imagemagick.org/][ImageMagick]] or [[http://www.graphicsmagick.org/][GraphicsMagick]] for twittering-mode (and pdf-tools)
- [[http://www.gzip.org/][gzip]]

* init.el
This goes in =init.el=. Lifted from the literate programming example
on [[http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][orgmode.org]].

#+begin_src emacs-lisp :tangle no
;;; init.el --- Where all the magic begins
;;
;; This file loads Org-mode and then loads the rest of our Emacs initialization from Emacs lisp
;; embedded in literate Org-mode files.

;; Load up Org Mode and (now included) Org Babel for elisp embedded in Org Mode files
(setq dotfiles-dir (file-name-directory (or (buffer-file-name) load-file-name)))

(let* ((org-dir (expand-file-name
                 "lisp" (expand-file-name
                         "org" (expand-file-name
                                "src" dotfiles-dir))))
       (org-contrib-dir (expand-file-name
                         "lisp" (expand-file-name
                                 "contrib" (expand-file-name
                                            ".." org-dir))))
       (load-path (append (list org-dir org-contrib-dir)
                          (or load-path nil))))
  ;; load up Org-mode and Org-babel
  (require 'org-install)
  (require 'ob-tangle))

;; load up all literate org-mode files in this directory
(mapc #'org-babel-load-file (directory-files dotfiles-dir t "\\.org$"))

;;; init.el ends here
#+end_src

* Packages setup
** Repositories
The ELPA repositories from where the packages are fetched.

These packages require melpa unstable: <2015-11-15>
- esh-buf
- ido-hacks
- rcirc-notify
- virtualenvwrapper
- helm-descbinds
- mc

These packages may benefit from melpa unstable: <2016-01-14>
- twittering-mode
- gist
- gh
- pcache
- org-beautify-theme

#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                           ("melpa-stable" . "https://stable.melpa.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")))

#+END_SRC

** use-package & bind-key
The [[https://github.com/jwiegley/use-package][use-package]] declaration macro allows us to isolate package configuration in
our emacs setup in a way that is performance-oriented and, well, just tidy. As
well it allows us to install automatically those packages that are not already
installed (using the =:ensure t= keyword) and freeing us to use a custom
bootstrap process.

It comes also with a module =bind-key= that helps us to manage the key bindings
in a better way. With those two utilities working in conjunction, we can
setup the packages atomically, with the ability to add/disable/delete packages.

You may need to install =use-package= by hand. In emacs 24 it was a 2014 version
that did not support =:pin=.

#+BEGIN_SRC emacs-lisp
  ;; To avoid problems with files newer than their byte-compiled counterparts
  ;; it's better a slower startup than load an outdated and maybe bugged package
  (setq load-prefer-newer t)
  ;; initialize the packages and create the packages list if not exists
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))

  ;; install use-package if not exists
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package)
    (use-package diminish
      :ensure t
      :pin melpa-stable)
    (use-package bind-key
      :ensure t
      :pin melpa-stable))
#+end_src

* Misc
** Theme
*Remember: when testing a new theme, disable before the current one or
use =helm-themes=.*

This code is to avoid to reload the theme every time that you open a new client
in server mode (from GUI or from terminal)

#+BEGIN_SRC emacs-lisp :tangle no
  (defun jhaus-cyberpunk ()
    (if (package-installed-p 'cyberpunk-theme)
    'cyberpunk
      'tango))

  (defun jhaus-monokai-ish ()
    (if (package-installed-p 'monokai-theme)
    'monokai
      'tango))

  (defvar jhaus-color-theme (jhaus-cyberpunk))

  (setq myGraphicModeHash (make-hash-table :test 'equal :size 2))
  (puthash "gui" t myGraphicModeHash)
  (puthash "term" t myGraphicModeHash)

  (defun emacsclient-setup-theme-function (frame)
    (let ((gui (gethash "gui" myGraphicModeHash))
      (ter (gethash "term" myGraphicModeHash)))
      (progn
    (select-frame frame)
    (when (or gui ter)
      (progn
        (load-theme jhaus-color-theme t)
        (if (display-graphic-p)
        (puthash "gui" nil myGraphicModeHash)
          (puthash "term" nil myGraphicModeHash))))
    (when (not (and gui ter))
      (remove-hook 'after-make-frame-functions 'emacsclient-setup-theme-function)))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions 'emacsclient-setup-theme-function)
    (progn (load-theme jhaus-color-theme t)))
#+END_SRC

** Toggle show trailing white-spaces
Show/hide the trailing white-spaces in the buffer.
from http://stackoverflow.com/a/11701899/634816

#+begin_src emacs-lisp
(defun jhaus-toggle-show-trailing-whitespace ()
  "Toggle show-trailing-whitespace between t and nil"
  (interactive)
  (setq show-trailing-whitespace (not show-trailing-whitespace)))
#+end_src

** find first non-ascii-char
Snagged this one from a stack overflow somewhere. It's super handy for those
invisibles that keep your files from compiling.

#+begin_src emacs-lisp
(defun jhaus-find-first-non-ascii-char ()
  "Find the first non-ascii character from point onwards."
  (interactive)
  (let (point)
    (save-excursion
      (setq point
            (catch 'non-ascii
              (while (not (eobp))
                (or (eq (char-charset (following-char))
                        'ascii)
                    (throw 'non-ascii (point)))
                (forward-char 1)))))
    (if point
        (goto-char point)
      (message "No non-ascii characters."))))
#+end_src

** lorem ipsum
Insert a sample paragraph at the mark.
#+begin_src emacs-lisp
(defun jhaus-lorem-ipsum ()
  "Insert a lorem ipsum."
  (interactive)
  (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
          "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
          "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
          "aliquip ex ea commodo consequat. Duis aute irure dolor in "
          "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
          "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
          "culpa qui officia deserunt mollit anim id est laborum."))
#+end_src

** TODO speed up large files

#+begin_src emacs-lisp
;; http://stackoverflow.com/questions/18316665/how-to-improve-emacs-performace-when-view-large-file
(defun my-find-file-check-make-large-file-read-only-hook ()
  "If a file is over a given size, make the buffer read only."
  (when (> (buffer-size) (* 1024 1024))
    (setq buffer-read-only t)
    (buffer-disable-undo)
    (fundamental-mode)))

(add-hook 'find-file-hooks 'my-find-file-check-make-large-file-read-only-hook)
#+end_src

** select-line
I got used to this while using sublime. It's handy, but perhaps there is a
better way.
#+begin_src emacs-lisp
(defun jhaus-expand-selection-to-line (arg)
  "Select the current line
  TODO: Doesn't expand current selected region to line"
  (interactive "p")
  (if (memq last-command '(jhaus-expand-selection-to-line))
      (progn
        (next-line)
        (beginning-of-line))
      (progn
        (set-mark (line-beginning-position))
        (next-line)
        (beginning-of-line))))

(global-set-key (kbd "C-l")  'jhaus-expand-selection-to-line)
#+end_src

** TODO super movement keys
gets me some of my custom keyboard stuff on a laptop keyboard

#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "s-o")  'jhaus/smart-move-to-line-beginning)
  (global-set-key (kbd "s-'")  'move-end-of-line)
  (global-set-key (kbd "s-<backspace>")  'jhaus/kill-word-or-region)

  (global-set-key (kbd "s-n")  'next-line)
  (global-set-key (kbd "s-e")  'previous-line)
  (global-set-key (kbd "s-h")  'backward-char)
  (global-set-key (kbd "s-i")  'forward-char)

  (global-set-key (kbd "C-s-n")  'forward-page)
  (global-set-key (kbd "C-s-e")  'backward-page)
  (global-set-key (kbd "C-s-h")  'backward-word)
  (global-set-key (kbd "C-s-i")  'forward-word)

#+end_src

** join line below
From [[http://pragmaticemacs.com/emacs/join-line-to-following-line/][Pragmatic Emacs]] joins the line below, ala vim. I guess this is
also bound to "C-u C-^", which is ridiculous. Alternatively one could
become one of those dirty join-from-belowers.

#+BEGIN_src emacs-lisp :tangle no
  (global-set-key (kbd "C-j")
                  (lambda ()
                    (interactive)
                    (join-line -1)))
#+END_src

** visual bell cursor
#+begin_src emacs-lisp

  ;; Visual Bell Cursor
  (setq ring-bell-function
        `(lambda ()
           ;; (setq-default cursor-type 'box)
           (set-cursor-color "#d9ca65")
           (sit-for .25)
           ;; (setq-default cursor-type 'box)
           (set-cursor-color "#f92671")))

  (setq-default set-cursor-color "#f92671")
  (setq-default cursor-type 'box)

#+end_src

** reopen file as root
Borrowed from [[https://github.com/coldnew/coldnew-spacemacs][coldnew's config]].
#+begin_src emacs-lisp
(defun sudo-reopen-file ()
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+end_src

** snippets from The Giraffe Book
*** TODO Other Window Backwards
Go back window.
#+begin_src emacs-lisp :tangle no
  (defun giraffe-other-window-backward (&optional n)
    "Select Nth previous window."
    (interactive "P")
    (other-window (- (prefix-numeric-value n))))

  (global-set-key "\C-x\C-p"     'giraffe-scroll-n-lines-behind) ;replaces mark-page!
#+end_src

*** Scroll Line
Scroll one line at a time, up or down.
#+begin_src emacs-lisp
  (defalias 'scroll-ahead  'scroll-up)
  (defalias 'scroll-behind 'scroll-down)

  (defun giraffe-scroll-n-lines-ahead (&optional n)
    "Scroll ahead N lines (1 by default)."
    (interactive "P")
    (scroll-ahead (prefix-numeric-value n)))

  (defun giraffe-scroll-n-lines-behind (&optional n)
    "Scroll behind N lines (1 by default)."
    (interactive "P")
    (scroll-behind (prefix-numeric-value n)))

  (global-set-key (kbd "M-<up>")     'giraffe-scroll-n-lines-behind) ;replaces quoted-insert
  (global-set-key (kbd "M-<down>")   'giraffe-scroll-n-lines-behind) ;replaces quoted-insert

  ;; (global-set-key "\C-q"     'giraffe-scroll-n-lines-behind) ;replaces quoted-insert
  ;; (global-set-key "\C-z"     'giraffe-scroll-n-lines-ahead) ;replaces suspend-emacs
  ;; (global-set-key "\C-x\C-q" 'quoted-insert) ;replaces read-only-mode
#+end_src

*** Cursor and Text Motion
#+begin_src emacs-lisp
  (defun giraffe-point-to-top ()
    "Put point on top line of window."
    (interactive)
    (move-to-window-line 0))

  (global-set-key "\M-," 'giraffe-point-to-top) ;replaces tags-loop-continue
  (global-set-key "\C-x," 'tags-loop-continue) ;replaces NOTHING!


  (defun giraffe-point-to-bottom ()
    "Put point at beginning of last visible line."
    (interactive)
    (move-to-window-line -1))

  (global-set-key "\M-." 'giraffe-point-to-bottom) ;replaces find-tag
  (global-set-key "\C-x." 'find-tag) ;replaces set-fill-prefix


  (defun giraffe-line-to-top ()
    "Move current line to top of window."
    (interactive)
    (recenter 0))

  ;; this is hard to press on my keyboard
  ;(global-set-key "\M-!" 'giraffe-line-to-top) ;replaces shell-command
#+end_src

** TODO weekly_report

#+begin_src emacs-lisp
(defun jhaus-weekly-report ()
  (interactive)
  (yas-minor-mode t)
  (markdown-mode)
  (yas-expand-snippet "---
${1:- Redesign MCP:
      hours: ${2:}
      comments: ${3:}}
${4:- Maintain and Modify Tools:
      hours: ${5:}
      comments: ${6:}}
${8:${10:- Perform Anomaly Investigation:
    hours: ${11:}
    comments: ${12:}}
${13:- Perform Field Support:
    hours: ${14:}
    comments: ${15:}}
${16:- ATCSCC Relocation:
    hours: ${17:}
    comments: ${18:}}
${19:- SCT Noise Study:
    hours: ${20:}
    comments: ${21:}}
${22:- SCT Relocation:
    hours: ${23:}
    comments: ${24:}}
${25:- Perform Offline Monitoring:
    hours: ${26:}
    comments: ${27:}}
${28:- Perform System Monitoring:
    hours: ${29:}
    comments: ${30:}}
${31:- Develop and Provide Training to Enhance WOS Skills:
    hours: ${32:}
    comments: ${33:}}
${34:- Develop WRE Bias and CNMP Tool:
    hours: ${35:}
    comments: ${36:}}
${37:- Investigate Increased RF Interference at WRSs:
    hours: ${38:}
    comments: ${39:})}"))
#+end_src

** smart-to-beginning of line
Spacemacs had it. Now I have it. (borrowed from [[http://stackoverflow.com/questions/6035872/moving-to-the-start-of-a-code-line-emacs][this guy]]).

#+begin_src emacs-lisp
  (defun jhaus/smart-move-to-line-beginning ()
    "Move point to the beginning of text on the current line; if that is already
  the current position of point, then move it to the beginning of the line."
    (interactive)
    (let ((pt (point)))
      (beginning-of-line-text)
      (when (eq pt (point))
        (beginning-of-line))))

  (global-set-key (kbd "<home>") 'jhaus/smart-move-to-line-beginning)
  (global-set-key (kbd "C-a")    'jhaus/smart-move-to-line-beginning)
#+end_src

** Yegge inspired C-w

backward-kill-word as alternative to Backspace:

Kill the entire word instead of hitting Backspace key several
times. To do this will bind the =backward-kill-region= function to the
=C-w= key combination

YEGGE RANTS - https://sites.google.com/site/steveyegge2/effective-emacs

Rather, we overload =C-w= so if no region is selected we delete the
last word. Better.

#+begin_src emacs-lisp
    (defun jhaus/kill-word-or-region (begining end)
      (interactive "r")
      (if (use-region-p)
          (kill-region begining end)
        (backward-kill-word 1)))

  (global-set-key (kbd "C-w") 'jhaus/kill-word-or-region)
#+end_src

** spaces to 72 (kinda dumb)

#+begin_src emacs-lisp
  ;; Have this idea about inserting spaces to 72.
  ;; Kind of lame.
  (defun jhaus/insert-trailing-spaces ()
    (interactive)
    (insert (make-string (- 72 (current-column)) ? )))
#+end_src

** Modern Page-up/down
Taken from the wiki:
http://www.emacswiki.org/emacs/Scrolling

The following shows how to use =condition-case= as an alternative
approach to extending the behavior for =scroll-up= and =scroll-down=.

When navigating the buffer with =scroll-up= and =scroll-down= - from
the traditional key bindings or otherwise - reaching the end of the
buffer isn't possible. In many applications, scrolling with Pgup or
Pgdn would eventually get you to the top or the bottom. Emacs on the
other hand will stop scrolling when the end of the buffer is
reached. The philosophy (read: religion) is that scrolling commands
are wholly separate from the point motion commands: Ideological purity
that is imposed on the user because by the
implementation. Fortunately, it doesn't take much to customize Emacs
to a more familiar behavior.

The following is from RyanBarrett's
blog. (https://snarfed.org/emacs_page_up_page_down)

#+begin_src emacs-lisp
  (global-set-key [next]
    (lambda () (interactive)
      (condition-case nil (scroll-up)
        (end-of-buffer (goto-char (point-max))))))

  (global-set-key [prior]
    (lambda () (interactive)
      (condition-case nil (scroll-down)
        (beginning-of-buffer (goto-char (point-min))))))

#+end_src

** TODO Rebinds
Would like to collect all the default rebinds in one place. At least
make a note of them here if they have to be somewhere else.
#+begin_src emacs-lisp :tangle no
(global-set-key (kbd "C-v") 'recenter)
#+end_src

** Enable stuff disabled by default
#+begin_src emacs-lisp
  ;; disabled because people find the term downcase confusing
  (put 'downcase-region 'disabled nil)
#+end_src

** Magnar's What The Emacs
I love this guy.
*** behold
Behold the very first lines in my .emacs.d/init.el:

;; Turn off mouse interface early in startup to avoid momentary display
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

;; No splash screen please ... jeez
(setq inhibit-startup-message t)
They hide the menu bar, tool bar, scroll bar and splash screen. Doing so early avoids ever having to see them - not even for a brief flash when starting Emacs.

These four lines move us into the tranquil zone of nothing but the text. A raster interface can never hold the seeming infinitude of Emacs functionality, so we just let it go.

*** pesky backup files
Annoyed by those pesky ~ files?

#+begin_src emacs-lisp
;; Write backup files to own directory
(setq backup-directory-alist
      `(("." . ,(expand-file-name
                 (concat user-emacs-directory "backups")))))

;; Make backups of files, even when they're in version control
(setq vc-make-backup-files t)
#+end_src

Backup files are so very annoying, until the day they save your
hide. That's when you don't want to look back and say "Man, I really
shouldn't have disabled those stupid backups."

These settings move all backup files to a central location. Bam! No
longer annoying.

As an added bonus, that last line makes sure your files are backed up
even when the files are in version control. Do it.

*** save file position
Tired of navigating back to where you were last in a file?
#+begin_src emacs-lisp
;; Save point position between sessions
(require 'saveplace)
(setq-default save-place t)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))
#+end_src

The saveplace package is part of Emacs, and remembers the position of
point - even between emacs sessions.

The last line sets the path to where saveplace stores your position
data. Change it at your peril! *

(Ahem, there really is no peril. That was just melodrama.)
*** slime
Do you program any elisp, at all, ever?

#+begin_src emacs-lisp :tangle no
;; Elisp go-to-definition with M-. and back again with M-,
(autoload 'elisp-slime-nav-mode "elisp-slime-nav")
(add-hook 'emacs-lisp-mode-hook (lambda () (elisp-slime-nav-mode t)))
(eval-after-load 'elisp-slime-nav '(diminish 'elisp-slime-nav-mode))
#+end_src

Then you need to M-x package-install elisp-slime-nav-mode.

It lets you jump to the definition of a function with M-., and back
again afterwards with M-,.

That last line says that we want elisp-slime-nav-mode to continue
doing its work for us, but we no longer want to be reminded of it.
*** webjump
Searching the web can also be improved with Emacs.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x g") 'webjump)

  ;; Add Urban Dictionary to webjump
  (eval-after-load "webjump"
    '(add-to-list 'webjump-sites
                  '("Urban Dictionary" .
                    [simple-query
                     "www.urbandictionary.com"
                     "http://www.urbandictionary.com/define.php?term="
                     ""])))
#+end_src

=Webjump= let's you quickly search Google, Wikipedia, Emacs Wiki and
other pages. I've got it bound to =C-x g=.

This snippet adds Urban Dictionary to the list of pages, so the next
time you wonder what those dastardly kids mean when they write
faceroll or sassafrassa or Technotard or kthxbye or whatever else is
hip these days, well, then you can find out. With webjump.
*** TODO magit frame juggling
todo: move to use-package magit
You are using magit with your git, right?

#+begin_src emacs-lisp :tangle no
;; full screen magit-status

(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))

(define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+end_src

This code makes magit-status run alone in the frame, and then restores
the old window configuration when you quit out of magit.

No more juggling windows after commiting. It's magit bliss.
---
Sounds great! Getting the following error:

Warning (initialization): An error occurred while loading ‘/home/jhaus/.emacs.d/init.el’:

Symbol's value as variable is void: magit-status-mode-map

To ensure normal operation, you should investigate and remove the
cause of the error in your initialization file.  Start Emacs with
the ‘--debug-init’ option to view a complete error backtrace.

*** stale dired buffers
Tired of seeing stale dired buffers?

Auto revert mode looks for changes to files, and updates them for you.

With these settings, dired buffers are also updated. The last setting
makes sure that you're not alerted every time this happens. Which is
every time you save something.

#+begin_src emacs-lisp
;; Auto refresh buffers
(global-auto-revert-mode 1)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

*** C-d in shell-mode
C-d on an empty line in the shell terminates the process.

With this snippet, another press of C-d will kill the buffer.

It's pretty nice, since you then just tap C-d twice to get rid of the
shell and go on about your merry way.

#+begin_src emacs-lisp
(defun comint-delchar-or-eof-or-kill-buffer (arg)
  (interactive "p")
  (if (null (get-buffer-process (current-buffer)))
      (kill-buffer)
    (comint-delchar-or-maybe-eof arg)))

(add-hook 'shell-mode-hook
          (lambda ()
            (define-key shell-mode-map
              (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))
#+end_src

*** Opening a new line
Opening new lines can be finicky.

With these shortcuts you can open a new line above or below the
current one, even if the cursor is midsentence.

#+begin_src emacs-lisp
  (defun open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-for-tab-command))

  (defun open-line-above ()
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (indent-for-tab-command))

  (global-set-key (kbd "<C-return>") 'open-line-below)
  (global-set-key (kbd "<C-S-return>") 'open-line-above)
#+end_src

*** move-line
When programming I tend to shuffle lines around a lot.

#+begin_src emacs-lisp
  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines 1))
      (forward-line)
      (move-to-column col)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (save-excursion
        (forward-line)
        (transpose-lines -1))
      (move-to-column col)))

  (global-set-key (kbd "<C-S-down>") 'move-line-down)
  (global-set-key (kbd "<C-S-up>") 'move-line-up)
#+end_src

Maybe not when I program elisp, since that's sexp-based, but for other
programming languages these two come in very handy. They simply move
the current line one step up or down.

*** rename file
For some reason, renaming the current buffer file is a multi-step
process in Emacs.

#+begin_src emacs-lisp
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))

  (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
#+end_src

This defun fixes that. And unlike some other alternatives to perform
this common task, you don't have to type the name out from scratch -
but get the current name to modify. Like it should be.
*** delete file
Like rename yesterday, I think delete deserves a designated keybinding.

#+begin_src emacs-lisp :tangle no
(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)
#+end_src

This is it. C-x C-k: file begone!

I like the feel between C-x k to kill the buffer and C-x C-k to kill
the file. Release ctrl to kill it a little, hold to kill it a lot.
*** clean up dired
I find the default dired look a bit spammy, especially in narrow windows.

#+begin_src emacs-lisp :tangle no
;; Make dired less verbose
(require 'dired-details)
(setq-default dired-details-hidden-string "--- ")
(dired-details-install)

#+end_src

By installing M-x package-install dired-details and using this
snippet, we hide all the unnecessary ls-details.

That rare occasion where you actually need that information, you can
show it with ) and hide again with (.
*** whitespace
Uneven application of white-space is bad, m'kay?

#+begin_src emacs-lisp
(defun cleanup-buffer-safe ()
  "Perform a bunch of safe operations on the whitespace content of a buffer.
Does not indent buffer, because it is used for a before-save-hook, and that
might be bad."
  (interactive)
  (untabify (point-min) (point-max))
  (delete-trailing-whitespace)
  (set-buffer-file-coding-system 'utf-8))

;; Various superfluous white-space. Just say no.
(add-hook 'before-save-hook 'cleanup-buffer-safe)

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (cleanup-buffer-safe)
  (indent-region (point-min) (point-max)))

(global-set-key (kbd "C-c n") 'cleanup-buffer)
#+end_src

I use these two literally all the time. The first one removes trailing
whitespace and replaces all tabs with spaces before save.

The last one I've got on a key - it also indents the entire buffer.

These might not be for everybody. Sometimes you do want tabs (I'm
looking at you Makefile grrrrr). Then this isn't optimal. The same can
be said for when Emacs doesn't indent correctly. But that is a horrid,
unacceptable situation in any case. I always fix those as soon as I
can.
*** ido fixes
Ido gives fuzzy matching in my completing-read. I want that everywhere.

;; Use ido everywhere
(require 'ido-ubiquitous)
(ido-ubiquitous-mode 1)

;; Fix ido-ubiquitous for newer packages
(defmacro ido-ubiquitous-use-new-completing-read (cmd package)
  `(eval-after-load ,package
     '(defadvice ,cmd (around ido-ubiquitous-new activate)
        (let ((ido-ubiquitous-enable-compatibility nil))
          ad-do-it))))

(ido-ubiquitous-use-new-completing-read webjump 'webjump)
(ido-ubiquitous-use-new-completing-read yas/expand 'yasnippet)
(ido-ubiquitous-use-new-completing-read yas/visit-snippet-file 'yasnippet)
ido-ubiquitous delivers on that promise.

However, there is some discrepancies in the completing-read API between newer and older versions regarding the case where you just press enter to choose the first item.

To fix these, some of the newer usages of completing read need a slightly different implementation. These tweaks fix that problem.
*** swap windows
Ever open a file in the wrong window?

(defun rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))

This snippet flips a two-window frame, so that left is right, or up is
down. It's sanity preserving if you've got a sliver of OCD.
*** toggle-window-split
Annoyed when Emacs opens the window below instead at the side?

#+begin_src emacs-lisp
  (defun toggle-window-split ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+end_src

This snippet toggles between horizontal and vertical layout of two
windows.

Neat.
*** sexp paredit paren-ing
Programming any lisp? Then this paredit-inspired snippet may be for you.

(defun paredit-wrap-round-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-round)
  (insert " ")
  (forward-char -1))

(define-key paredit-mode-map (kbd "M-)")
  'paredit-wrap-round-from-behind)

With point in front of a sexp, paredit-wrap-round (bound to M-(), will
open a paren in front the the sexp, and place the closing paren at the
end of it. That's pretty handy.

This snippet does the same, but from the other end. It saves me a
C-M-b ever so often. I like it.
*** more paredit
Yesterday Kototama commented about another neat paredit addition: duplicating sexps. This is my take on that:

(defun paredit--is-at-start-of-sexp ()
  (and (looking-at "(\\|\\[")
       (not (nth 3 (syntax-ppss))) ;; inside string
       (not (nth 4 (syntax-ppss))))) ;; inside comment

(defun paredit-duplicate-closest-sexp ()
  (interactive)
  ;; skips to start of current sexp
  (while (not (paredit--is-at-start-of-sexp))
    (paredit-backward))
  (set-mark-command nil)
  ;; while we find sexps we move forward on the line
  (while (and (bounds-of-thing-at-point 'sexp)
              (<= (point) (car (bounds-of-thing-at-point 'sexp)))
              (not (= (point) (line-end-position))))
    (forward-sexp)
    (while (looking-at " ")
      (forward-char)))
  (kill-ring-save (mark) (point))
  ;; go to the next line and copy the sexprs we encountered
  (paredit-newline)
  (yank)
  (exchange-point-and-mark))
Like Kototama says in his blogpost, duplicating a line is very useful, but sometimes it leads to invalid sexps. In the blogpost he shows a snippet that will duplicate the sexp after point. I immediately realized I had really been wanting this.

The version listed here is a little modified: It will duplicate the sexp you are currently inside, or looking at, or looking behind at. So basically, point can be in any of these positions:

  |(my sexp) ;; in front
  (my| sexp) ;; inside
  (my sexp)| ;; at the end
Insta-useful!
*** maredit delete-section-mode
I love the symbiosis between expand-region and delete-selection-mode.

;; making paredit work with delete-selection-mode
(put 'paredit-forward-delete 'delete-selection 'supersede)
(put 'paredit-backward-delete 'delete-selection 'supersede)
(put 'paredit-open-round 'delete-selection t)
(put 'paredit-open-square 'delete-selection t)
(put 'paredit-doublequote 'delete-selection t)
(put 'paredit-newline 'delete-selection t)
This makes paredit-mode work with delete-selection-mode, replacing its wrapping behavior. If I want to wrap, I'll do it with the paredit-wrap-* commands explicitly.
*** macbook meta-keys
Everybody knows about moving Control to Caps Lock. These are my extra
neat tricks for my MacBook Pro:

(setq mac-command-modifier 'meta)
(setq mac-option-modifier 'super)
(setq ns-function-modifier 'hyper)

First of all, Meta M- needs to be really easy to hit. On a Mac
keyboard, that means Command - and not the default Option - since we
want the key that is right next to Space.

The good news is that now Option is available for Super s-. And even
more amazing, you can also bind the Function-key to Hyper H- - without
losing the ability to change the volume or pause/play.

So now I can use crazy keybindings like H-SPC hyperspace. I haven't
entirely decided what I should be using this newfound superpower for,
but one thing I've done is reserve all the C-s- prefixed letters for
refactorings with js2-refactor, as you can see here.
*** move more quickly
There are lots of neat ways of moving around quickly in a buffer.

;; Move more quickly
(global-set-key (kbd "C-S-n")
                (lambda ()
                  (interactive)
                  (ignore-errors (next-line 5))))

(global-set-key (kbd "C-S-p")
                (lambda ()
                  (interactive)
                  (ignore-errors (previous-line 5))))

(global-set-key (kbd "C-S-f")
                (lambda ()
                  (interactive)
                  (ignore-errors (forward-char 5))))

(global-set-key (kbd "C-S-b")
                (lambda ()
                  (interactive)
                  (ignore-errors (backward-char 5))))

For instance, check out Emacs Rocks e10: Jumping Around.

But sometimes I just want to browse a little. Or move a few lines
down. These keybindings let me do that more quickly than C-n C-n C-n
C-n C-n C-n ...

In fact, with these I can navigate to any line within a distance of 11
in 3 keystrokes or less. Or close enough to count. Two of them require
4 keystrokes. Can you figure out which ones?
*** join lines M-j
Here's one keybinding I could not live without.
#+begin_src emacs-lisp
(global-set-key (kbd "M-j")
            (lambda ()
                  (interactive)
                  (join-line -1)))
#+end_src

It joins the following line onto this one.

Let's say I want to collapse this paragraph-tag to one line:

  <p class="example">
    Some text
    over multiple
    lines.
  </p>

With point anywhere on the first line, I simply press M-j multiple
times to pull the lines up.
*** find-files by extension
I use Phil Hagelbergs' find-file-in-project, but fuzzy matching with LOTS of files can be suboptimal.

;; Function to create new functions that look for a specific pattern
(defun ffip-create-pattern-file-finder (&rest patterns)
  (lexical-let ((patterns patterns))
    (lambda ()
      (interactive)
      (let ((ffip-patterns patterns))
        (find-file-in-project)))))

;; Find file in project, with specific patterns
(global-unset-key (kbd "C-x C-o"))
(global-set-key (kbd "C-x C-o ja")
                (ffip-create-pattern-file-finder "*.java"))
(global-set-key (kbd "C-x C-o js")
                (ffip-create-pattern-file-finder "*.js"))
(global-set-key (kbd "C-x C-o jp")
                (ffip-create-pattern-file-finder "*.jsp"))

This function limits the search to files of a specific file type. I've
got loads more of these keybindings, all of them with the two-letter
mnemonic shortcut.

It really speeds up finding files. Both because ido-completing-read
has less matches to worry about, because there are fewer similarly
named files, and especially when the .java, the .js and the .jsp share
a name.
*** dired M->
In dired, M-> and M- never take me where I want to go.

#+begin_src emacs-lisp :tangle no
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (dired-next-line 4))

(define-key dired-mode-map
  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (dired-next-line -1))

(define-key dired-mode-map
  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
#+end_src

That is, now they do.

Instead of taking me to the very beginning or very end, they now take
me to the first or last file.
*** ido go home
Okay, this is a bad idea if your files are prefixed with ~.

(add-hook 'ido-setup-hook
 (lambda ()
   ;; Go straight home
   (define-key ido-file-completion-map
     (kbd "~")
     (lambda ()
       (interactive)
       (if (looking-back "/")
           (insert "~/")
         (call-interactively 'self-insert-command))))))
But if they're not, this keybinding lets you even more quickly reach your home folder when in ido-find-file.

It doesn't matter if you're a million directories in, just press ~ to go home.
*** html-mode forward/back paragraph
In html-mode, forward/backward-paragraph is infuriatingly slow.

(defun skip-to-next-blank-line ()
  (interactive)
  (let ((inhibit-changing-match-data t))
    (skip-syntax-forward " >")
    (unless (search-forward-regexp "^\\s *$" nil t)
      (goto-char (point-max)))))

(defun skip-to-previous-blank-line ()
  (interactive)
  (let ((inhibit-changing-match-data t))
    (skip-syntax-backward " >")
    (unless (search-backward-regexp "^\\s *$" nil t)
      (goto-char (point-min)))))

(eval-after-load "sgml-mode"
  '(progn
     (define-key html-mode-map
       [remap forward-paragraph] 'skip-to-next-blank-line)

     (define-key html-mode-map
       [remap backward-paragraph] 'skip-to-previous-blank-line)))

I use them a lot for quick navigation. In html-mode, they are anything
but quick.

Defining paragraphs in Emacs is black magic, and I'm not sure it's a
good idea to change that in case something else relies on its erratic
behavior.

Instead I just remap the commands to my home brewed
skip-to-next/previous-blank-line. Ahh, speedy and predictable
navigation once more.
*** org-mode todo [17/23]
I mainly use org-mode for a collection of TODO-lists.

(defun myorg-update-parent-cookie ()
  (when (equal major-mode 'org-mode)
    (save-excursion
      (ignore-errors
        (org-back-to-heading)
        (org-update-parent-todo-statistics)))))

(defadvice org-kill-line (after fix-cookies activate)
  (myorg-update-parent-cookie))

(defadvice kill-whole-line (after fix-cookies activate)
  (myorg-update-parent-cookie))
So I get a little annoyed when the [17/23] cookies at the parent level aren't updated when I remove an item.

This code fixes that.
*** store project settings
Where do you put your project specific settings?
#+begin_src emacs-lisp :tangle no
(defmacro project-specifics (name &rest body)
  (declare (indent 1))
  `(progn
     (add-hook 'find-file-hook
               (lambda ()
                 (when (string-match-p ,name (buffer-file-name))
                   ,@body)))
     (add-hook 'dired-after-readin-hook
               (lambda ()
                 (when (string-match-p ,name (dired-current-directory))
                   ,@body)))))

(project-specifics "projects/zombietdd"
  (set (make-local-variable 'slime-js-target-url) "http://localhost:3000/")
  (ffip-local-patterns "*.js" "*.jade" "*.css" "*.json" "*.md"))
#+end_src

I created this macro to help me set up local vars. So in the example,
any files in projects/zombietdd will see these slime-js-target-url and
the find-file-in-projects patterns.

I keep these in a projects-folder to keep track of all the different
settings for my projects.
*** undo in region
Undo in region is one of those mind-blowing things about
emacs. However, the region keeps jumping about when I use it. So I
added this:

#+begin_src emacs-lisp
  ;; Keep region when undoing in region
  (defadvice undo-tree-undo (around keep-region activate)
    (if (use-region-p)
        (let ((m (set-marker (make-marker) (mark)))
              (p (set-marker (make-marker) (point))))
          ad-do-it
          (goto-char p)
          (set-mark m)
          (set-marker p nil)
          (set-marker m nil))
      ad-do-it))
#+end_src

Now the region stays in place while I'm undoing.

Since I use undo-tree, that's what it advises, but I would guess it
works the same for regular old undo too.
*** clean modeline
I already covered the awesomely commented diminish.el. Here's another trick to reduce the cruft in your modeline:

(defmacro rename-modeline (package-name mode new-name)
  `(eval-after-load ,package-name
     '(defadvice ,mode (after rename-modeline activate)
        (setq mode-name ,new-name))))

(rename-modeline "js2-mode" js2-mode "JS2")
(rename-modeline "clojure-mode" clojure-mode "Clj")
With this, I reduce the js2-mode modeline lighter from "JavaScript IDE" to just "JS2".

I stole it from Bodil's .emacs.d and macroified it a little. The first
argument is the package name, the second is the mode in question, and
the third is the new lighter for the mode.
*** re-indent sgm-delete-tag?
Ever been annoyed at the lack of reindentation after using sgml-delete-tag?

;; after deleting a tag, indent properly
(defadvice sgml-delete-tag (after reindent activate)
  (indent-region (point-min) (point-max)))
Be annoyed no more!

This blogpost brought to you live from WebRebels 2013.
*** magit quick amend
I mess up a lot, and often want to do a quick amend to the last commit.

#+begin_src emacs-lisp
;; C-c C-a to amend without any prompt

(defun magit-just-amend ()
  (interactive)
  (save-window-excursion
    (magit-with-refresh
      (shell-command "git --no-pager commit --amend --reuse-message=HEAD"))))

(eval-after-load "magit"
  '(define-key magit-status-mode-map (kbd "C-c C-a") 'magit-just-amend))
#+end_src

This code will let me just press C-c C-a and it amends with no fuss at all.

Thanks to this post for the inspiration.

Update! As noted by Kyle Meyer in the comments below, this no longer
works in the newest magit. Instead you should be using the built in
Extend Commit command: c e.
*** contribute to emacs
Now that Emacs has moved to git, maybe it's time to start contributing directly? Here's how you build Emacs from source on OS X:

git clone git://git.savannah.gnu.org/emacs.git
cd emacs
./autogen.sh
./configure --with-ns
make install
cd nextstep
open Emacs.app

For more info and instructions for other distros, see Lars' post.
** jhaus
#+begin_src emacs-lisp
  (defun jhaus-invert-color-at-mark ()
    "select hex color at point and replace it with its complement"
    (interactive)
    (let (p1 p2)
      (save-excursion
        (skip-chars-backward "#A-Za-z0-9")
        (setq p1 (point))
        (skip-chars-forward "#A-Za-z0-9")
        (setq p2 (point))
        (setq color (buffer-substring-no-properties p1 p2))
        (insert (color-complement-hex color))
        (delete-region p1 p2))))
  (global-set-key (kbd "C-c i") 'jhaus-invert-color-at-mark)

#+end_src

* Built-ins
** Defaults
Just some defaults to get us going.

#+BEGIN_SRC emacs-lisp
  ;;(when (display-graphic-p)
    (progn
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
      (fringe-mode '(10 . 5))              ; makes the fringe too small for git-gutter
      ;; Sloppy focus
      (setq focus-follows-mouse t)
      (setq mouse-autoselect-window t)
      (setq-default truncate-lines t)
  ) ;)

  (setq inhibit-startup-screen t                ;; the welcome screen is for guests only, I'm at home now!
        initial-scratch-message nil             ;; remove the message in the scratch buffer
        visible-bell nil                          ;; remove the annoying beep
        apropos-do-all t                        ;; apropos commands perform more extensive searches than default
        large-file-warning-threshold 100000000) ;; warn only when opening files bigger than 100MB
  ;; no bars, no gui menus

  (menu-bar-mode -1)
  ;; replace yes/no questions with y/n
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; show the empty lines at the end (bottom) of the buffer
  ;(toggle-indicate-empty-lines)
  ;; delete the previous selection when overrides it with a new insertion.
  (delete-selection-mode)
  ;; the blinking cursor is pretty annoying, so disable it.
  (blink-cursor-mode t)
  ;; highlight the current line (no thanks)
  (global-hl-line-mode 0)
  ;; more thinner window divisions
  ;; tab-complete only if line is properly indented already
  (setq tab-always-indent t)

  ;; Fix some keybinds
  (global-set-key (kbd "C-x f") 'find-file) ;; set-fill-column by default, ugh
  (global-set-key (kbd "C-x C-p") 'project-find-file)  ;; mark-page by default

  ;; use ibuffer by default
  (defalias 'list-buffers 'ibuffer)

  ;; keep the buffer in sync with the file system
  (global-auto-revert-mode t)

  ;; make sure that UTF-8 is used everywhere.
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-language-environment    'utf-8)
  (set-selection-coding-system 'utf-8)
  (setq locale-coding-system   'utf-8)
  (prefer-coding-system        'utf-8)
  (set-input-method nil)
  (set-default-coding-systems 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))


  ;; DISABLE LOCK FILES
  (setq create-lockfiles nil)

  ;; DISABLE AUTO-SAVE FILES & BACKUPS
  ;; I prefer to use a undo-tree with branches instead of store auto-save
  ;; files. Because I'm using gpg to authetication and encrypt/sign files,
  ;; is more secure don't have a plaint text backup of those files. Use a
  ;; DVCS and backup your files regularly, for God's sake!
  (setq auto-save-default nil
        auto-save-list-file-prefix nil
        make-backup-files nil)

  ;; Get backtraces on errors
  (setq debug-on-error t)

  ;; always indent with spaces
  (setq-default indent-tabs-mode  nil
                default-tab-width 4
                c-basic-offset 4)

  ;; show the matching parenthesis when the cursor is above one of them.
  (setq show-paren-delay 0)
  (show-paren-mode t)

  ;; settings for the mode line
  (column-number-mode t)
  (setq size-indication-mode t)
  (which-function-mode 1)

  ;; Hettinger has something to say about this.
  ;; text wrapping at 80 columns by default (only text)
  ;; (add-hook 'text-mode-hook 'turn-on-auto-fill) ;hard wraps, ew.
  ;; (add-hook 'text-mode-hook
  ;;           '(lambda() (set-fill-column 80)))

  ;; browser settings
  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;       browse-url-generic-program "chromium")

  (setq browse-url-browser-function 'eww-browse-url
        browse-url-generic-program "eww")

  ;; disable these warnings about narrow
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)

  ;; sets the default user's information properly.
  (setq user-full-name    "Jesse Haubrich"
        user-mail-address "jesse.haubrich@gmail.com")

  ;; https://www.gnu.org/software/emacs/manual/html_mono/flymake.html#Configuring-Flymake
  (setq flymake-start-syntax-check-on-find-file nil)
#+END_SRC

** TODO zap-up-to-char
todo: better keybind please. I think it would actually be useful and
even fun if it were on a key I could actually press.
#+begin_src emacs-lisp
  (autoload 'zap-up-to-char "misc" "Kill up to, but not including ARGth occurrence of CHAR.")
  (global-set-key (kbd "M-Z") 'zap-to-char)
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+end_src

** TODO prettify-symbols
This is coming in emacs 25.1
http://endlessparentheses.com/new-in-emacs-25-1-have-prettify-symbols-mode-reveal-the-symbol-at-point.html?source=rss

#+begin_src emacs-lisp :tangle no
  (setq prettify-symbols-unprettify-at-point 'right-edge)
#+end_src

** TODO Font
The font to use. +I choose monospace and Dejavu Sans Mono because is an+
+open font and has the best Unicode support, and looks very fine to me+
+too.+

[[https://github.com/adobe-fonts/source-code-pro][Source Code Pro]] FTW

TODO: Disabled because it looks better without. Fonts are bolded and ugly. No longer true?
#+begin_src emacs-lisp
  ;; (when (display-graphic-p) (progn
  ;; (set-face-attribute 'default nil :family "Dejavu Sans Mono" :height 110 :weight 'light)
  (set-default-font "Source Code Pro-11")

  ;; Set a font with great support for Unicode Symbols to fallback in
  ;; those case where certain Unicode glyphs are missing in the current
  ;; font.
  ;; (set-fontset-font "fontset-default" nil
  ;;                   (font-spec :size 16 :name "Symbola"))
  ;; ))
#+end_src

#+RESULTS:

** Org-mode

General settings...
#+BEGIN_SRC emacs-lisp
  (setq
   ;; quick modie commads when at the start of a header. I like.
   org-use-speed-commands t
   ;; I don't remember what this does.
   org-src-fontify-natively t
   ;; nice indentation helps immensely
;   org-startup-indented t
   ;; this setting should crawl the heirarchy to add everything to the
   ;; summary e.g. [0/5]
   org-checkbox-hierarchical-statistics t
   )
#+END_SRC

Allow org-babel to execute blocks of code. Has to be explicit?
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   `( (sh . t)
      (python . t)))
#+end_src

*** Strike-through using +
+testing the strike-through+
#+begin_src emacs-lisp
(require 'cl)   ; for delete*
(setq org-emphasis-alist
      (cons '("+" '(:strike-through t :foreground "dark gray"))
            (delete* "+" org-emphasis-alist :key 'car :test 'equal)))
#+end_src

*** TODO refile
We can add some org files to this to make refiling work across all of
our org files.

Org-refile by default only does the top level headings. [[http://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/][Thanks
@sachau]].

- [ ] need to add some files to the org-agenda-files first.
#+begin_src emacs-lisp :tangle no
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
#+end_src

*** Capture templates
as described by [[http://www.howardism.org/Technical/Emacs/journaling-org.html][Howardism]] and the [[http://orgmode.org/manual/Capture-templates.html][org-mode manual]]. "C-c c j" should
open a buffer for making a journal entry.

#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/Dropbox/_notes_/gtd.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("m" "Music" entry (file+headline "~/Dropbox/_notes_/music.org" "Music Notes")
           "* %?\n  %i\n")
          ("r" "Quotes" plain (file "~/Dropbox/_notes_/quotes")
           "%\n%? \n\n    -- %^{Author's Name}")
          ("j" "Journal" entry (file+datetree "~/Dropbox/_notes_/journal.org")
           "* %?\nEntered on %U\n  %i\n  %a")
          ("w" "Work Journal" entry (file+datetree "~/Dropbox/_notes_/work_journal.org")
           "* %?\nEntered on %U\n  %i\n  %a\n")))

(global-set-key (kbd "M-m") 'org-capture)
#+end_src

** eshell
Eshell can be powerful when used in the right way. Most of this is
borrowed from Howardism's [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][eshell article]].

This is mostly borrowed from [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Howardism's eshell config]].

*** starter kit
https://github.com/gabrielelanaro/emacs-starter-kit
https://eschulte.github.io/emacs24-starter-kit/starter-kit-eshell.html is another similar.

This seems to improve completion quite a bit.

#+begin_src emacs-lisp
;;; starter-kit-eshell.el --- Making the defaults a bit saner
;;
;; Part of the Emacs Starter Kit

(setq eshell-cmpl-cycle-completions t
      eshell-cmpl-ignore-case t
      eshell-save-history-on-exit t
      eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'")

(eval-after-load 'esh-opt
  '(progn
     (require 'em-prompt)
     (require 'em-term)
     (require 'em-cmpl)
     (setenv "PAGER" "cat")
     (set-face-attribute 'eshell-prompt nil :foreground "turquoise1")
     (add-hook 'eshell-mode-hook ;; for some reason this needs to be a hook
               '(lambda () (eshell/export "TERM" "dumb")))

     ;; TODO: submit these via M-x report-emacs-bug
     (add-to-list 'eshell-visual-commands "ssh")
     (add-to-list 'eshell-visual-commands "tail")
     (add-to-list 'eshell-command-completions-alist
                  '("gunzip" "gz\\'"))
     (add-to-list 'eshell-command-completions-alist
                  '("tar" "\\(\\.tar|\\.tgz\\|\\.tar\\.gz\\)\\'"))))

(defun eshell/cds ()
  "Change directory to the project's root."
  (eshell/cd (locate-dominating-file default-directory "src")))

;; (defun eshell/find (dir &rest opts)
;;   (find-dired dir (mapconcat 'identity opts " ")))

;; (defun eshell/scp (&rest args)
;;   "scp: now without colon-omitting annoyance!"
;;   (when (null (remove-if-not (lambda (arg) (string-match ":" arg))
;;                              args))
;;     (error "Surely you meant to add a colon in there somewhere?"))
;;   (shell-command (mapconcat 'identity (cons "scp" args) " ")))

;; Port features from
;; http://blog.peepcode.com/tutorials/2009/shell-method-missing/shell_method_missing.rb
;; * cloning git repos, github repos
;; * downloading http urls
;; * extracting archives
;; * changing to directories

(provide 'starter-kit-eshell)
;;; starter-kit-eshell.el ends here
#+END_src

*** TODO hacks
*Visual Executables*, eshell would get somewhat confused if I ran the following
commands directly through the normal Elisp library, as these need the better
handling of ansiterm:

#+begin_src emacs-lisp :tangle no
  ;; (add-hook 'eshell-mode-hook
  ;;    (lambda ()
  ;;       (add-to-list 'eshell-visual-commands "ssh")
  ;;       (add-to-list 'eshell-visual-commands "tail")))

  (eval-after-load 'eshell
    '(progn
      (setq eshell-visual-commands
            '("ssh" "tail" "less" "tmux" "htop" "top" "bash" "zsh" "fish"))

      (setq eshell-visual-subcommands
            '(("git" "log" "diff" "show")))
      ))
#+end_src

*Ignoring Directories*, great shell with some good tweaks taken from the
Starter Kit project. Ignoring the .git directories seem like a good idea.

#+begin_src emacs-lisp :tangle no
(setq eshell-cmpl-cycle-completions nil
      eshell-save-history-on-exit t
      eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'")
#+end_src

*** Better Command Line History
[[http://www.reddit.com/r/emacs/comments/1zkj2d/advanced_usage_of_eshell/][On this discussion]] a little gem for using IDO to search back through the
history, instead of =M-R= to display the history in a selectable buffer.

Also, while =M-p= cycles through the history, =M-P= actually moves up the
history in the buffer (easier than =C-c p= and =C-c n=?):

#+begin_src emacs-lisp
  (add-hook 'eshell-mode-hook
       (lambda ()
         ;; (local-set-key (kbd "M-P") 'eshell-previous-prompt)
         ;; (local-set-key (kbd "M-N") 'eshell-next-prompt)
         ;; (local-set-key (kbd "M-R") 'eshell-list-history)
         (local-set-key (kbd "C-n") 'eshell-next-matching-input-from-input)
         (local-set-key (kbd "C-p") 'eshell-previous-matching-input-from-input)
         (local-set-key (kbd "<up>") 'previous-line)
         (local-set-key (kbd "<down>") 'next-line)
         (local-set-key (kbd "C-<up>") 'eshell-previous-prompt)
         (local-set-key (kbd "C-<down>") 'eshell-next-prompt)

         (local-set-key (kbd "M-r")
                (lambda ()
                  (interactive)
                  (insert
                   (ido-completing-read "Eshell history: "
                                        (delete-dups
                                         (ring-elements eshell-history-ring))))))))
#+end_src

*** TODO plan 9
#+BEGIN_SRC emacs-lisp :tangle no
  (require 'eshell)
  (add-hook 'eshell-mode-hook 'eshell-smart-initialize)
  (require 'em-smart)
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
#+end_src

*** Aliases
Quality of life improvements using [[http://www.emacswiki.org/emacs/EshellAlias][eshell aliases]].

#+BEGIN_SRC emacs-lisp

  ;;If any program wants to pause the output through the $PAGER variable, well, we don't really need that:
  (setenv "PAGER" "cat")

  (defun eshell/e (file)
    (find-file file))
  (defun eshell/ee (file)
    (find-file-other-window file))
  ;;Pull up dired, but without parameters, just use the current directory.
  (defun eshell/d (&rest args)
    (dired (pop args) "."))
  ;; ll
  (add-hook 'eshell-mode-hook
            (lambda ()
              ;; The 'ls' executable requires the Gnu version on the Mac
              (let ((ls (if (file-exists-p "/usr/local/bin/gls")
                            "/usr/local/bin/gls"
                          "/bin/ls")))
                (eshell/alias "ll" (concat ls " -AlohG --color=always")))))

#+end_src

*** Git
My gst command is just an alias to magit-status, but using the alias does not pull in the current working directory, so I make it a function, instead:

#+begin_src emacs-lisp
  (defun eshell/gst (&rest args)
      (magit-status (pop args) nil)
      (eshell/echo))   ;; The echo command suppresses output

  ;; What about gd to call the Diff command?

  (defalias 'gd 'magit-diff-unstaged)
  (defalias 'gds 'magit-diff-staged)
#+end_src

*** Git Prompt

Following these instructions, we build a better prompt with the Git branch in it
(Of course, it matches my Bash prompt). First, we need a function that returns a
string with the Git branch in it, e.g. :master

#+begin_src emacs-lisp
(defun curr-dir-git-branch-string (pwd)
  "Returns current git branch as a string, or the empty string if
PWD is not in a git repo (or the git command is not found)."
  (interactive)
  (when (and (eshell-search-path "git")
             (locate-dominating-file pwd ".git"))
    (let ((git-output (shell-command-to-string (concat "sh -c \"cd " pwd " && git branch | grep '\\*' | sed -e 's/^\\* //'\""))))
      (if (> (length git-output) 0)
          (concat " :" (substring git-output 0 -1))
        "(no branch)"))))
#+end_src

The function takes the current directory passed in via pwd and replaces the
$HOME part with a tilde. I'm sure this function already exists in the eshell
source, but I didn't find it.

#+begin_src emacs-lisp
(defun pwd-replace-home (pwd)
  "Replace home in PWD with tilde (~) character."
  (interactive)
  (let* ((home (expand-file-name (getenv "HOME")))
         (home-len (length home)))
    (if (and
         (>= (length pwd) home-len)
         (equal home (substring pwd 0 home-len)))
        (concat "~" (substring pwd home-len))
      pwd)))
#+end_src

Make the directory name be shorter by replacing all directory names with just
its first names. However, we leave the last two to be the full names. Why yes, I
did steal this.

#+begin_src emacs-lisp
(defun pwd-shorten-dirs (pwd)
  "Shorten all directory names in PWD except the last two."
  (let ((p-lst (split-string pwd "/")))
    (if (> (length p-lst) 2)
        (concat
         (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                               (substring elm 0 1)))
                    (butlast p-lst 2)
                    "/")
         "/"
         (mapconcat (lambda (elm) elm)
                    (last p-lst 2)
                    "/"))
      pwd  ;; Otherwise, we just return the PWD
      )))

;; Turn off the default prompt.
(setq eshell-highlight-prompt nil)
#+end_src

Break up the directory into a parent and a base:

#+begin_src emacs-lisp
(defun split-directory-prompt (directory)
  (if (string-match-p ".*/.*" directory)
      (list (file-name-directory directory) (file-name-base directory))
    (list "" directory)))
#+end_src

Now tie it all together with a prompt function can color each of the prompts components.

#+begin_src emacs-lisp
(setq eshell-prompt-function
      (lambda ()
        (let* ((directory (split-directory-prompt (pwd-shorten-dirs (pwd-replace-home (eshell/pwd)))))
               (parent (car directory))
               (name (cadr directory))
               (branch (or (curr-dir-git-branch-string (eshell/pwd)) "")))

          (if (eq 'dark (frame-parameter nil 'background-mode))
              (concat   ;; Prompt for Dark Themes
               (propertize parent 'face `(:foreground "#8888FF"))
               (propertize name   'face `(:foreground "#8888FF" :weight bold))
               (propertize branch 'face `(:foreground "#0168e0"))
               (propertize " $"   'face `(:weight ultra-bold))
               (propertize " "    'face `(:weight bold)))

            (concat    ;; Prompt for Light Themes
             (propertize parent 'face `(:foreground "blue"))
             (propertize name   'face `(:foreground "blue" :weight bold))
             (propertize branch 'face `(:foreground "#0168e0"))
             (propertize " $"   'face `(:weight ultra-bold))
             (propertize " "    'face `(:weight bold)))))))
#+end_src

Turn off the default prompt, otherwise, it wont use ours:
#+begin_src emacs-lisp
(setq eshell-highlight-prompt nil)
#+end_src

*** eshell-here
#+begin_src emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
    current buffer's file. The eshell is renamed to match that
    directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (global-set-key (kbd "C-!") 'eshell-here)

  ;; This only works with a windowed eshell like eshell-here creates
  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))

#+end_src

*** TODO eshell packages
Note: =esh-buf= is not in melpa-stable <2015-11-15>
.
Looks like  is causing emacs to hang on startup.

#+begin_src emacs-lisp :tangle no
  (use-package esh-buf-stack
    :ensure t
    :config
    (setup-eshell-buf-stack)
    (add-hook 'eshell-mode-hook
              (lambda ()
                (local-set-key (kbd "M-q") 'eshell-push-command))))
#+end_src

eshell-prompt-extras is causing emacs to hang on load, but everything works as
expected once it comes up.
#+begin_src emacs-lisp :tangle no
  (use-package eshell-prompt-extras
    :ensure t
    :config
    (eval-after-load 'esh-opt
      (progn
        (require 'eshell-prompt-extras)
        (setq eshell-highlight-prompt nil
              eshell-prompt-function 'epe-theme-lambda))))
    ; If you want to display python virtual environment information:
    ;; (eval-after-load 'esh-opt
    ;;   (progn
    ;;     (require 'virtualenvwrapper)
    ;;     (venv-initialize-eshell)
    ;;     (require 'eshell-prompt-extras)
    ;;     (setq eshell-highlight-prompt nil
    ;;           eshell-prompt-function 'epe-theme-lambda))))
#+end_src

** ediff
A more sane default configuration to ediff.

#+begin_src emacs-lisp
(use-package ediff
  :init
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally))
#+end_src

** eww
Settings for the Emacs Web Browser.

#+begin_src emacs-lisp
(use-package eww
  :init
  (setq eww-download-directory "~/Downloads")
  :config
  (bind-keys :map eww-mode-map
             ("s" . eww-view-source)))
#+end_src

** spelling
Turn on spell checking by default, and use hunspell instead of ispell.

#+begin_src emacs-lisp :tangle no
  (setq-default ispell-program-name    "hunspell")
                ;; ispell-really-hunspell t
                ;; ispell-check-comments  t
                ;; ispell-extra-args      '("-i" "utf-8") ;; produce a lot of noise, disable?
                ;; ispell-dictionary      "en_US")

  (defun jhaus-turn-on-spell-check ()
    (flyspell-mode 1))

  ;; enable spell-check in certain modes
  (add-hook 'markdown-mode-hook 'jhaus-turn-on-spell-check)
  (add-hook 'text-mode-hook     'jhaus-turn-on-spell-check)
  (add-hook 'org-mode-hook      'jhaus-turn-on-spell-check)
  ;add-hook 'prog-mode-hook     'flyspell-prog-mode)
#+end_src

** TODO desktop-save
You can save the current desktop and reload one saved in another
directory by typing M-x desktop-change-dir. Typing =M-x desktop-revert=
reverts to the desktop previously reloaded.

Specify the option =--no-desktop= on the command line when you don’t
want it to reload any saved desktop. This turns off =desktop-save-mode=
for the current session.

#+begin_src emacs-lisp :tangle no
  (setq desktop-path '("~/.emacs.d/tmp/"))
  (setq desktop-dirname "~/.emacs.d/tmp/")
  (setq desktop-base-file-name "emacs-desktop")
  (setq desktop-globals-to-save
        (append '((extended-command-history . 50)
                  (file-name-history . 200)
                  (grep-history . 50)
                  (compile-history . 50)
                  (minibuffer-history . 100)
                  (query-replace-history . 100)
                  (read-expression-history . 100)
                  (regexp-history . 100)
                  (regexp-search-ring . 100)
                  (search-ring . 50)
                  (shell-command-history . 50)
                  tags-file-name
                  register-alist)))
  (desktop-save-mode 1)

#+end_src

* Packages
** arch-package-build
#+BEGIN_src emacs-lisp
(autoload 'pkgbuild-mode "pkgbuild-mode.el" "PKGBUILD mode." t)
(setq auto-mode-alist (append '(("/PKGBUILD$" . pkgbuild-mode)) auto-mode-alist))
#+end_src

** Better Defaults
Some of this is duplicated in the config.
https://github.com/technomancy/better-defaults

#+begin_src emacs-lisp :tangle no
  (use-package better-defaults
    :ensure t)
#+end_src

*** New behaviour
- =ido-mode= allows many operations (like buffer switching and file
  navigation) to be enhanced with instant feedback among the
  completion choices. If you like ido, you should check out [[https://github.com/scottjad/ido-hacks][ido-hacks]]
  and [[https://github.com/nonsequitur/smex][smex]]. Sometimes when creating a new file you'll want to
  temporarily disable ido; this can be done with =C-f=. You may also
  want to look at [[http://www.archivum.info/emacs-devel@gnu.org/2010-04/00629/ChangeLog-entry-for-ido.el.html][=ido-use-virtual-buffers=]].
- The toolbar, menu bar, and scroll bar are all turned off.
- The =uniquify= library makes it so that when you visit two files
  with the same name in different directories, the buffer names have
  the directory name appended to them instead of the silly =hello<2>=
  names you get by default.
- The =saveplace= library saves the location of the point when you
  kill a buffer and returns to it next time you visit the associated
  file.
- A few key bindings are replaced with more powerful equivalents:
  =M-/= is =hippie-expand= instead of =dabbrev-expand=, =C-x C-b= is
  =ibuffer= instead of =list-buffers=, and =C-s= and =C-r= are swapped
  with regex-aware incremental search functions.
- =show-paren-mode= highlights the matching pair when the point is
  over parentheses.
- Under X, killing and yanking uses the X clipboard rather than just
  the primary selection.
- Apropos commands perform more extensive searches than default.
- Mouse yanking inserts at the point instead of the location of the
  click.
- Backups are stored inside =user-emacs-directory=. (Usually
  =~/.emacs.d=)
- =M-z= (formerly =zap-to-char=) is replaced with the far more useful
  =zap-up-to-char=.
- =require-final-newline= is set to avoid problems with crontabs, etc.
- Setting =load-prefer-newer= prevents stale elisp bytecode from
  shadowing more up-to-date source files.
- Ediff is set up to use the existing frame instead of creating a new
  one.
- =indent-tabs-mode= defaults to nil.

** Guide-key
https://github.com/kai2nenobu/guide-key
#+begin_src emacs-lisp
  (use-package guide-key
    :ensure t
    :diminish guide-key-mode
    :config
    (setq guide-key/guide-key-sequence '("C-x" "C-c"))
    (setq guide-key/recursive-key-sequence-flag t)
    (guide-key-mode 1))
#+end_src

** bug-hunter

[[./img/bug_hunter.png]]

[[https://github.com/Malabarba/elisp-bug-hunter][The Bug Hunter]] is an Emacs library that finds the source of an error or
unexpected behavior inside an elisp configuration file (typically =init.el= or
=.emacs=).

#+BEGIN_SRC emacs-lisp
  (use-package bug-hunter
    :ensure t
    :commands (bug-hunter-file bug-hunter-init-file))
#+END_SRC

** charmap

[[./img/charmap.png]]

[[https://github.com/lateau/charmap][Charmap]] is Unicode table viewer for Emacs. With CharMap you can see the Unicode
table based on The Unicode Standard 6.2.

#+BEGIN_SRC emacs-lisp
  (use-package charmap
    :commands charmap
    :defer t
    :ensure t
    :config
    (setq charmap-text-scale-adjust 2))
#+END_SRC

** csv-mode

[[https://github.com/emacsmirror/csv-mode][csv-mode]] is a major mode for editing comma/char separated values.

| Binding | Call                    | Do                                                                     |
|---------+-------------------------+------------------------------------------------------------------------|
| C-c C-v | csv-toggle-invisibility | Toggle invisibility of field separators when aligned                   |
| C-c C-t | csv-transpose           | Rewrite rows (which may have different lengths) as columns             |
| C-c C-c | csv-set-comment-start   | Set comment start for this CSV mode buffer to STRING                   |
| C-c C-u | csv-unalign-fields      | Undo soft alignment and optionally remove redundant white space        |
| C-c C-a | csv-align-fields        | Align all the fields in the region to form columns                     |
| C-c C-z | csv-yank-as-new-table   | Yank fields as a new table starting at point                           |
| C-c C-y | csv-yank-fields         | Yank fields as the ARGth field of each line in the region              |
| C-c C-k | csv-kill-fields         | Kill specified fields of each line in the region                       |
| C-c C-d | csv-toggle-descending   | Toggle csv descending sort ordering                                    |
| C-c C-r | csv-reverse-region      | Reverse the order of the lines in the region                           |
| C-c C-n | csv-sort-numeric-fields | Sort lines in region numerically by the ARGth field of each line       |
| C-c C-s | csv-sort-fields         | Sort lines in region lexicographically by the ARGth field of each line |
|---------+-------------------------+------------------------------------------------------------------------|

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :ensure t
    :mode "\\.csv\\'")
#+END_SRC

** page-break-lines
[[https://github.com/purcell/page-break-lines][page-break-lines]] provides a global mode which displays ugly form feed characters
=^L= as tidy horizontal rules.

#+BEGIN_SRC emacs-lisp
    (use-package page-break-lines
      :ensure t
      :diminish page-break-lines-mode
      :config
      (global-page-break-lines-mode t))
#+END_SRC

** magnar's multiple cursors

Note: Might want to look at: https://github.com/knu/mc-extras.el
Note: don't use melpa stable.. <2015-11-15>

[[https://github.com/magnars/multiple-cursors.el][Magnar's Multiple cursors]] for Emacs. This is some pretty crazy functionality, so yes,
there are kinks. Don't be afraid tho, I've been using it since 2011 with great
success and much merriment.

*Tips and tricks*
- To get out of multiple-cursors-mode, press <return> or C-g. The latter will
  first disable multiple regions before disabling multiple cursors. If you want
  to insert a newline in multiple-cursors-mode, use C-j.

- Sometimes you end up with cursors outside of your view. You can scroll the
  screen to center on each cursor with C-v and M-v or you can press C-' to hide
  all lines without a cursor, press C-' again to unhide.

- Try pressing mc/mark-next-like-this with no region selected. It will just add
  a cursor on the next line.

- Try pressing mc/mark-all-like-this-dwim on a tagname in html-mode.

- Notice that the number of cursors active can be seen in the modeline.

- If you get out of multiple-cursors-mode and yank - it will yank only from the
  kill-ring of main cursor. To yank from the kill-rings of every cursor use
  yank-rectangle, normally found at C-x r y.

- You can use mc/reverse-regions with nothing selected and just one cursor. It
  will then flip the sexp at point and the one below it.

- When you use mc/edit-lines, you can give it a positive or negative prefix to
  change how it behaves on too short lines.

- If you would like to keep the global bindings clean, and get custom
  keybindings when the region is active, you can try region-bindings-mode.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :config
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click))
#+end_src

** magnar's expand region
[[https://github.com/magnars/expand-region.el][Expand region]] increases the selected region by semantic units. Just keep
pressing the key until it selects what you want.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :config
    (global-set-key (kbd "C-c v") 'er/expand-region))
#+end_src

** ag

[[./img/ag.png]]

[[https://github.com/Wilfred/ag.el][ag.el]] is a simple Emacs frontend to ag, ("the silver searcher" ack replacement).

#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t
    :defer 1
    :config
    (progn
      (setq ag-reuse-buffers 't
            ag-highlight-search t
            ag-arguments (list "--color" "--smart-case" "--nogroup" "--column" "--all-types" "--"))))
#+END_SRC

** rcirc
Note: =rcirc-notify= is not in melpa-stable. <2015-11-15>

There is alot that can be borrowed from spacemacs here.

#+begin_src emacs-lisp
  ;; IRC configuration
  (use-package rcirc
    :ensure t
    :config
    (setq rcirc-server-alist
          '(("info.amc.faa.gov" :port 47382
             :user "jesse"
             :channels ("#waas" "#sog" "#zombies")))
          rcirc-omit-responses '("MODE")
          rcirc-notify-timeout 15  ;; secs to repress from same user
          )
    (add-hook 'rcirc-mode-hook (lambda ()
                                 (flyspell-mode 1))))
  (use-package rcirc-notify
    :ensure t
    :config
    (rcirc-notify-add-hooks))
#+end_src

** Dired
Two ways to avoid to use more than one buffer when using Dired.

#+begin_src emacs-lisp
(use-package dired
   :init
   ;; 'a' reuses the current buffer, 'RET' opens a new one
   (put 'dired-find-alternate-file 'disabled nil)

   ;; '^' reuses the current buffer
   (add-hook 'dired-mode-hook
             (lambda ()
               (define-key dired-mode-map (kbd "^")
                 (lambda ()
                   (interactive)
                   (find-alternate-file ".."))))))

#+end_src

** async
[[https://github.com/jwiegley/emacs-async][async.el]] is a module for doing asynchronous processing in Emacs.

#+begin_src emacs-lisp
(use-package async
  :defer t
  :ensure t)
#+end_src

** DONE company-mode
Company-mode has always been buggy and in the way. This configuration
needs serious revision and should probably just go.

#+begin_src emacs-lisp
  (use-package company
    :pin melpa-stable
    :ensure t
    :config (progn
              (add-hook 'after-init-hook 'global-company-mode)
              (setq company-tooltip-align-annotations t) ;; align right
              ;; (setq company-idle-delay 3)
              ;; (setq company-minimum-prefix-length 2)
              ;; (setq company-dabbrev-downcase nil)
              ;; (setq company-dabbrev-other-buffers t)
              ;; ;; (setq company-auto-complete nil)
              ;; (setq company-dabbrev-code-other-buffers 'all)
              ;; (setq company-dabbrev-code-everywhere t)
              ;; (setq company-dabbrev-code-ignore-case t)
              ;; (global-set-key (kbd "C-<tab>") 'company-dabbrev)
              (global-set-key (kbd "C-<tab>") 'company-complete)
              (global-set-key (kbd "C-c C-y") 'company-yasnippet)

              ;; (setq company-idle-delay 0)
              ;; (setq company-minimum-prefix-length 3)
              ;; (setq company-auto-complete t)
              ;; (setq company-auto-complete-chars "(){}[],.:")

              ;; arrow keys exit and C-n/p select #minor-annoyance
              (define-key company-active-map (kbd "<up>") nil)
              (define-key company-active-map (kbd "<down>") nil)
              (define-key company-active-map (kbd "C-n") 'company-select-next)
              (define-key company-active-map (kbd "C-p") 'company-select-previous)

              ;; (define-key company-active-map [tab] 'company-complete)
              ;; (define-key company-active-map (kbd "TAB") 'company-complete)

              ;; this is what said do in the emacswiki (probably wrong)
              ;; (global-set-key (kbd "C-.") 'company-manual-begin)
              ;; (global-set-key "\t" 'company-complete-common)

    ))
#+end_src

** TODO auto-complete
[[https://github.com/auto-complete/auto-complete][Auto Complete Mode]] (aka =auto-complete.el=, =auto-complete-mode=) is a extension
that automates and advances completion-system.

This is always so annoying. Lets try: TAB complete. up/down initiate menu.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package auto-complete
    :ensure t
    :pin melpa-stable
    :diminish auto-complete-mode
    :config
    (progn
      (ac-config-default)
      ;; https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md

      ;; Finish completion by TAB

      ;; As we described above, there is many behaviors in TAB. You
      ;; need to use TAB and RET properly, but there is a simple
      ;; interface that bind RET to original and TAB to finish
      ;; completion:

      (define-key ac-completing-map "\t" 'ac-complete)
      (define-key ac-completing-map "\r" nil)

      ;; my own changes
      (define-key ac-completing-map "\C-e" 'ac-complete)
      (define-key ac-completing-map [up] nil)
      (define-key ac-completing-map [down] nil)
      (define-key ac-menu-map [up] nil)
      (define-key ac-menu-map [down] nil)


      ;; THERE were weird bugs, some of this might be ok...
      ;; (global-auto-complete-mode)
      ;; (add-to-list 'ac-sources 'ac-source-abbrev)
      ;; (add-to-list 'ac-sources 'ac-source-dictionary)
      ;; (add-to-list 'ac-sources 'ac-source-filename)
      ;; (add-to-list 'ac-sources 'ac-source-imenu)
      ;; (add-to-list 'ac-sources 'ac-source-semantic)
      ;; (add-to-list 'ac-sources 'ac-source-words-in-buffer)
      ;; (add-to-list 'ac-sources 'ac-source-yasnippet)

      ;; (setq ac-use-menu-map t
      ;;       ac-ignore-case 'smart
      ;;       ac-auto-start t
      ;;       ac-auto-show-menu nil)

      ;; (ac-flyspell-workaround)
      ;; (define-key ac-completing-map "<tab>" 'ac-next)
      ;; (define-key ac-completing-map "\C-n>" 'ac-next) (ac-)
      ;; (define-key ac-completing-map "<backtab>" 'ac-previous)
      )

    ;; the file where store the history of auto-complete.
    (setq ac-comphist-file (concat user-emacs-directory
                                   "temp/ac-comphist.dat"))

    ;; dirty fix for having AC everywhere
    (define-globalized-minor-mode real-global-auto-complete-mode
      auto-complete-mode (lambda ()
                           (if (not (minibufferp (current-buffer)))
                               (auto-complete-mode 1))
                           ))
    (real-global-auto-complete-mode t))
#+END_SRC

** magit
With [[https://github.com/magit/magit][Magit]], you can inspect and modify your Git repositories with
Emacs. You can review and commit the changes you have made to the
tracked files, for example, and you can browse the history of past
changes. There is support for cherry picking, reverting, merging,
rebasing, and other common Git operations.

#+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :pin melpa-stable
      ;:diminish magit-auto-revert-mode
      :commands magit-status)
    (setq magit-last-seen-setup-instructions "1.4.0")
#+END_SRC

** git-gutter-fringe+
[[https://github.com/nonsequitur/git-gutter-fringe-plus][Git Gutter Fringe+]] on git-hub, there are allot of customization not
used here.

=git-gutter-fringe+= locks up during install and while loading on
startup.

#+begin_src emacs-lisp
;  (when (display-graphic-p)
    (use-package git-gutter-fringe
      :ensure t
      :diminish git-gutter-mode
      :init
      (global-git-gutter-mode)) ;)
#+end_src

** git-timemachine
#+begin_src emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+end_src

** ibuffer-vc

[[https://github.com/purcell/ibuffer-vc][ibuffer-vc]] show the buffers grouped by the associated version control
project.

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :ensure t
    :commands ibuffer
    :init
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))
    :config
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  filename-and-process))))
#+END_SRC

** undo-tree

[[http://www.dr-qubit.org/emacs.php#undo-tree][undo-tree]] is a version of the same Vim's feature for Emacs

Emacs's undo system allows you to recover any past state of a buffer
(the standard undo/redo system loses any "redoable" states whenever
you make an edit). However, Emacs's solution, to treat "undo" itself
as just another editing action that can be undone, can be confusing
and difficult to use.

Both the loss of data with standard undo/redo and the confusion of
Emacs' undo stem from trying to treat undo history as a linear
sequence of changes. =undo-tree-mode= instead treats undo history as
what it is: a branching tree of changes (the same system that Vim has
had for some time now). This makes it substantially easier to undo and
redo any change, while preserving the entire history of past states.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :init
    (progn
      (global-undo-tree-mode)))
      ;; (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/tmp/undo"))
      ;;       undo-tree-visualizer-timestamps t
      ;;       undo-tree-visualizer-diff t
      ;;       undo-tree-auto-save-history t)))
#+END_SRC

** TODO popwin

[[https://github.com/m2ym/popwin-el][Popwin]] is a popup window manager for Emacs which makes you free from
the hell of annoying buffers such like *Help*, *Completions*,
*compilation*, and etc.

#+BEGIN_SRC emacs-lisp :tangle no
    (use-package popwin
      :ensure t
      :config
      (popwin-mode 1)
      (setq popwin:popup-window-height 35
            popwin:special-display-config
            '(("*Miniedit Help*" :noselect t)
              (help-mode :noselect nil)
              (completion-list-mode :noselect t)
              (compilation-mode :noselect nil)
              (grep-mode :noselect t)
              (occur-mode :noselect t)
              ("*Pp Macroexpand Output*" :noselect t)
              ("*Shell Command Output*")
              ("*Async Shell Command*")
              ("*vc-diff*")
              ("*vc-change-log*")
              (" *undo-tree*" :width 60 :position right)
              ("^\\*anything.*\\*$" :regexp t)
              ("*slime-apropos*")
              ("*slime-macroexpansion*")
              ("*slime-description*")
              ("*slime-compilation*" :noselect t)
              ("*slime-xref*")
              ("*Flycheck errors*")
              ("*Warnings*")
              ("*Process List*")
              ("*Smex: Unbound Commands*")
              ("*Paradox Report*" :noselect nil)
              ("*Diff*" :noselect nil)
              ("*Messages*" :noselect nil)
              ("*Google Maps*" :noselect nil)
              ("*ag search*" :noselect nil)
              ("*PDF-Occur*" :noselect nil)
              ("*PDF-Metadata*" :noselect nil)
              ("^\\*Outline .*\\.pdf\\*$" :regexp t :noselect nil)
              ("*MULTI-TERM-DEDICATED*" :noselect nil :stick t)
              (sldb-mode :stick t)
              (slime-repl-mode)
              (slime-connection-list-mode)))



      (bind-keys :map popwin:window-map
                 ((kbd "<escape>") . popwin:close-popup-window)))
#+END_SRC

** TODO Amit-mode-line (Inverted)
Saw this on @emacs_gifs!

https://twitter.com/emacs_gifs/status/758842634924208128

‏@emacs_gifs: @90shilling let me hook you up with
this. https://github.com/ocodo/.emacs.d/blob/4ee41e847027dcb0a79509714cf0d6363396dc3a/custom/amitp-mode-line.el
… the version in my .emacs.d


#+begin_src emacs-lisp :tangle no
  ;;; amitp-mode-line.el --- Mode line customisation and beautification by Amit J Patel
  ;;; Author: Amit J Patel <amitp@cs.stanford.edu>

  ;;; Version: 1.0

  ;;; Commentary:
  ;;  Just a lovely mode line customisation - Packaged from the blog post at
  ;;  http://amitp.blogspot.sg/2011/08/emacs-custom-mode-line.html

  ;;; Licence: GPL

  ;;; Code:

  ;;;###autoload
  (defun amitp-mode-line ()
    "Just a lovely mode line customisation."
    (interactive)
    (setq-default
     mode-line-format
     '(; Position, including warning for 80 columns
       (:propertize "%4l:" face mode-line-position-face)
       (:eval (propertize "%3c" 'face
                          (if (>= (current-column) 80)
                              'mode-line-80col-face
                            'mode-line-position-face)))
       mode-line-client
       "  "
       (:eval
        (cond (buffer-read-only
               (propertize " RO " 'face 'mode-line-read-only-face))
              ((buffer-modified-p)
               (propertize " ** " 'face 'mode-line-modified-face))
              (t "      ")))
       "    "
                                          ; directory and buffer/file name
       (:propertize (:eval (shorten-directory default-directory 30))
                    face mode-line-folder-face)
       (:propertize "%b"
                    face mode-line-filename-face)
                                          ; narrow [default -- keep?]
       " %n "
       (:eval
        (if (and (boundp 'evil-mode-line-tag) evil-mode-line-tag)
            (format "%s" evil-mode-line-tag)
          (format "   ")))
                                          ; mode indicators: vc, recursive edit, major mode, minor modes, process, global
       (vc-mode vc-mode)
       "  %["
       (:propertize mode-name
                    face mode-line-mode-face)
       "%] "
       (:eval (propertize (format-mode-line minor-mode-alist)
                          'face 'mode-line-minor-mode-face))
       (:propertize mode-line-process
                    face mode-line-process-face)
       (global-mode-string global-mode-string)
       "    "
       ))

    ;; Helper function
    (defun shorten-directory (dir max-length)
      "Show up to `max-length' characters of a directory name `dir'."
      (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
            (output ""))
        (when (and path (equal "" (car path)))
          (setq path (cdr path)))
        (while (and path (< (length output) (- max-length 4)))
          (setq output (concat (car path) "/" output))
          (setq path (cdr path)))
        (when path
          (setq output (concat ".../" output)))
        output))

    ;; Extra mode line faces
    (make-face 'mode-line-read-only-face)
    (make-face 'mode-line-modified-face)
    (make-face 'mode-line-folder-face)
    (make-face 'mode-line-filename-face)
    (make-face 'mode-line-position-face)
    (make-face 'mode-line-mode-face)
    (make-face 'mode-line-minor-mode-face)
    (make-face 'mode-line-process-face)
    (make-face 'mode-line-80col-face)

    (set-face-attribute 'mode-line nil
                        :inherit 'mode-line-face
                        :foreground "#656565" :background "#cbcbcb"
                        :height 120
                        :inverse-video nil
                        :box '(:line-width 6 :color "#cbcbcb" :style nil))
    (set-face-attribute 'mode-line-inactive nil
                        :inherit 'mode-line-face
                        :foreground "#323232" :background "#989898"
                        :inverse-video nil
                        :box '(:line-width 6 :color "#989898" :style nil))
    (set-face-attribute 'mode-line-read-only-face nil
                        :inherit 'mode-line-face
                        :foreground "#bd8e51"
                        :box '(:line-width 2 :color "#bd8e51"))
    (set-face-attribute 'mode-line-modified-face nil
                        :inherit 'mode-line-face
                        :foreground "#37d7d6"
                        :background "#000000"
                        :box '(:line-width 2 :color "#37d7d6"))
    (set-face-attribute 'mode-line-folder-face nil
                        :inherit 'mode-line-face
                        :foreground "#656565")
    (set-face-attribute 'mode-line-filename-face nil
                        :inherit 'mode-line-face
                        :foreground "#1548ff"
                        :weight 'bold)
    (set-face-attribute 'mode-line-position-face nil
                        :inherit 'mode-line-face
                        :height 100)
    (set-face-attribute 'mode-line-mode-face nil
                        :inherit 'mode-line-face
                        :foreground "#323232")
    (set-face-attribute 'mode-line-minor-mode-face nil
                        :inherit 'mode-line-face
                        :foreground "#4b4b4b"
                        :height 90)
    (set-face-attribute 'mode-line-process-face nil
                        :inherit 'mode-line-face
                        :foreground "#8e72ff")
    (set-face-attribute 'mode-line-80col-face nil
                        :inherit 'mode-line-face-position-face
                        :foreground "#ffffff" :background "#1548ff")
    )

  (provide 'amitp-mode-line)

  ;;; amitp-mode-line.el ends here

  (amitp-mode-line)

#+end_src

** Amit-mode-line
Saw this on @emacs_gifs!

https://twitter.com/emacs_gifs/status/758842634924208128

‏@emacs_gifs: @90shilling let me hook you up with
this. https://github.com/ocodo/.emacs.d/blob/4ee41e847027dcb0a79509714cf0d6363396dc3a/custom/amitp-mode-line.el
… the version in my .emacs.d


#+begin_src emacs-lisp
  ;;; amitp-mode-line.el --- Mode line customisation and beautification by Amit J Patel
  ;;; Author: Amit J Patel <amitp@cs.stanford.edu>

  ;;; Version: 1.0

  ;;; Commentary:
  ;;  Just a lovely mode line customisation - Packaged from the blog post at
  ;;  http://amitp.blogspot.sg/2011/08/emacs-custom-mode-line.html

  ;;; Licence: GPL

  ;;; Code:

  ;;;###autoload
  (defun amitp-mode-line ()
    "Just a lovely mode line customisation."
    (interactive)
    (setq-default
     mode-line-format
     '(; Position, including warning for 80 columns
       (:propertize "%4l:" face mode-line-position-face)
       (:eval (propertize "%3c" 'face
                          (if (>= (current-column) 80)
                              'mode-line-80col-face
                            'mode-line-position-face)))
       mode-line-client
       "  "
       (:eval
        (cond (buffer-read-only
               (propertize " RO " 'face 'mode-line-read-only-face))
              ((buffer-modified-p)
               (propertize " ** " 'face 'mode-line-modified-face))
              (t "      ")))
       "    "
                                          ; directory and buffer/file name
       (:propertize (:eval (shorten-directory default-directory 30))
                    face mode-line-folder-face)
       (:propertize "%b"
                    face mode-line-filename-face)
                                          ; narrow [default -- keep?]
       " %n "
       (:eval
        (if (and (boundp 'evil-mode-line-tag) evil-mode-line-tag)
            (format "%s" evil-mode-line-tag)
          (format "   ")))
                                          ; mode indicators: vc, recursive edit, major mode, minor modes, process, global
       (vc-mode vc-mode)
       "  %["
       (:propertize mode-name
                    face mode-line-mode-face)
       "%] "
       (:eval (propertize (format-mode-line minor-mode-alist)
                          'face 'mode-line-minor-mode-face))
       (:propertize mode-line-process
                    face mode-line-process-face)
       (global-mode-string global-mode-string)
       "    "
       ))

    ;; Helper function
    (defun shorten-directory (dir max-length)
      "Show up to `max-length' characters of a directory name `dir'."
      (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
            (output ""))
        (when (and path (equal "" (car path)))
          (setq path (cdr path)))
        (while (and path (< (length output) (- max-length 4)))
          (setq output (concat (car path) "/" output))
          (setq path (cdr path)))
        (when path
          (setq output (concat ".../" output)))
        output))

    ;; Extra mode line faces
    (make-face 'mode-line-read-only-face)
    (make-face 'mode-line-modified-face)
    (make-face 'mode-line-folder-face)
    (make-face 'mode-line-filename-face)
    (make-face 'mode-line-position-face)
    (make-face 'mode-line-mode-face)
    (make-face 'mode-line-minor-mode-face)
    (make-face 'mode-line-process-face)
    (make-face 'mode-line-80col-face)

    (set-face-attribute 'mode-line nil
                        :inherit 'mode-line-face
                        :foreground "#9a9a9a" :background "black"
                        :height 120
                        :inverse-video nil
                        :box '(:line-width 2 :color "gray10" :style nil))
    (set-face-attribute 'mode-line-inactive nil
                        :inherit 'mode-line-face
                        :foreground "#cdcdcd" :background "gray22"
                        :inverse-video nil
                        :box '(:line-width 3 :color "gray10" :style nil))
    (set-face-attribute 'mode-line-read-only-face nil
                        :inherit 'mode-line-face
                        :foreground "#4171ae"
                        :box '(:line-width 2 :color "#4171ae"))
    (set-face-attribute 'mode-line-modified-face nil
                        :inherit 'mode-line-face
                        :foreground "#c82828"
                        :background "#000000"
                        :box '(:line-width 2 :color "#c82828"))
    (set-face-attribute 'mode-line-folder-face nil
                        :inherit 'mode-line-face
                        :foreground "#9a9a9a")
    (set-face-attribute 'mode-line-filename-face nil
                        :inherit 'mode-line-face
                        :foreground "#eab700"
                        :weight 'bold)
    (set-face-attribute 'mode-line-position-face nil
                        :inherit 'mode-line-face
                        :height 100)
    (set-face-attribute 'mode-line-mode-face nil
                        :inherit 'mode-line-face
                        :foreground "#cdcdcd")
    (set-face-attribute 'mode-line-minor-mode-face nil
                        :inherit 'mode-line-face
                        :foreground "#b3b3b3"
                        :height 90)
    (set-face-attribute 'mode-line-process-face nil
                        :inherit 'mode-line-face
                        :foreground "#718d00")
    (set-face-attribute 'mode-line-80col-face nil
                        :inherit 'mode-line-face-position-face
                        :foreground "#000000" :background "#eab700")
    )

  (provide 'amitp-mode-line)

  ;;; amitp-mode-line.el ends here

  (amitp-mode-line)

#+end_src

** TODO monokai-theme
[[https://github.com/oneKelvinSmith/monokai-emacs][Monokai for Emacs]] is a port of the popular TextMate theme Monokai by Wimer
Hazenberg.

#+BEGIN_SRC emacs-lisp
  (use-package monokai-theme
    :defer t
    :ensure t)
#+END_SRC

** TODO monokai-inverted-theme
My inverted Monokai theme
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'load-path "~/src/monokai-inverted-theme")
  (load "monokai-inverted-theme")
#+END_SRC

** TODO monokai-inverted-overrides
#+begin_src emacs-lisp :tangle no
  ;;; monokai-overrides -- Some custom overrides for the monokai theme

  ;;; Commentary:
  ;; Currently used solely for the Company tooltip

  ;;; Code:
  (deftheme monokai-inverted-overrides)

  (let ((class '((class color) (min-colors 257)))
        (terminal-class '((class color) (min-colors 89))))

    (custom-theme-set-faces
     'monokai-inverted-overrides

     ;; Company-mode
     `(company-tooltip
       ((t :inherit default
           :background "gainsboro"
           :foreground "DimGrey")))

     `(company-scrollbar-bg
       ((t :background "#dddad9")))

     `(company-scrollbar-fg
       ((t :background "grey")))

     `(company-preview
       ((t :background "gainsboro"
           :foreground "DarkGrey")))

     `(company-tooltip-selection
       ((t :inherit font-lock-function-name-face
           :background "DarkGrey"
           :foreground "Gainsboro"
           :bold t)))

     `(company-preview-common
       ((t (:foreground "DimGrey"))))

     `(company-tooltip-common
       ((t :inherit font-lock-constant-face
           :foreground "DimGrey"
           :underline t)))

     `(company-tooltip-common-selection
       ((t :background "DarkGrey"
           :foreground "Gainsboro"
           :underline t)))

     `(font-lock-comment-face
       ((t :foreground "#777777"
           :slant italic)))

     `(company-tooltip-annotation
       ((t :background nil
           :foreground "DimGrey")))

     `(company-tooltip-annotation-selection
       ((t ( :foreground "DarkGrey"))))

     ;; Auto-complete

     `(ac-candidate-face ((t (:background "snow3" :foreground "#992610"))))
     `(popup-summary-face ((t (:inherit popup-face :background "snow3" :foreground "dimgray"))))


     ;; Flymake
     `(flymake-errline ((t (:underline nil))))
     `(flymake-warnline ((t (:underline nil))))

     ;; Org-mode
     `(org-block ((t (:background "gainsboro" :foreground "#07070f"))))
     `(org-block-background ((t (:background "gainsboro"))))
     `(org-block-begin-line ((t (:background "gainsboro" :slant italic))) t)
     `(org-block-end-line ((t (:background "gainsboro" :slant italic))) t)
     `(org-verbatim ((t (:weight extra-bold :height 0.9 :family "Source Code Pro"))))

  ))

  (provide-theme `monokai-inverted-overrides)
#+end_src

** TODO cybepunk-theme
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package cyberpunk-theme
    :defer t
    :ensure t)
#+END_SRC

** DONE noctilux-theme
#+BEGIN_SRC emacs-lisp
  (use-package noctilux-theme
    :defer t
    :ensure t)
#+END_SRC

** TODO dracula-theme
#+begin_src emacs-lisp :tangle no
  (use-package dracula-theme
    :ensure t
    :pin melpa-stable)
#+end_src

** TODO Darktooth theme
Used by @emacs_gifs
https://gtertithub.com/emacsfodder/emacs-theme-darktooth

#+begin_src emacs-lisp :tangle no
(use-package darktooth-theme
  :defer t
  :ensure t)
#+end_src

** TODO Darktooth-inverted
#+BEGIN_src emacs-lisp :tangle no
  (add-to-list 'load-path "~/src/emacs-theme-darktooth-inverted")
  (load "darktooth-theme-inverted")
#+end_src

** TODO Org-beautify-theme
#+BEGIN_SRC emacs-lisp
  (use-package org-beautify-theme
    :defer t
    :ensure t)
#+END_SRC
*** org-beautify-theme (old and by hand)
https://github.com/jonnay/org-beautify-theme

#+begin_src emacs-lisp :tangle no
  ;;; org-beautify-theme.el --- A sub-theme to make org-mode more beautiful.
  ;; Copyright (C) 2014-2016 Jonathan Arkell

  ;; Author: Jonathan Arkell <jonnay@jonnay.net>
  ;; Version: 0.2
  ;; Created: 5 Oct 2012
  ;; Keywords: org theme

  ;; This file is not part of GNU Emacs.
  ;; Released under the GPL v3.0

  ;;; Commentary:
  ;; <<commentary>>

  ;;; Code:

  (deftheme org-beautify "Sub-theme to beautify org mode")
#+end_src

**** Making Org-mode Beautiful
***** This theme is dedicated to my wife Shell
  Who—in her beauty, her love, and her love for beauty—has shown me
  that form can enhance function.
***** Mission
  - Make org mode headlines easy to read.  In any theme.
  - Make it look more like a published book and/or desktop app, less
    like angry fruit salad.
  - Make it awesome to live in an org buffer.
***** Usage
  Load this theme over top your existing theme, and you should be
  golden.  If you find any incompatibilities, let me know with what
  theme and I will try and fix it.

  When loading a whole new theme overtop, org-beautify-theme will
  still be active with the old theme.  Just unload org-beautify-theme
  and then reload it, and everything will be fine again.

***** Changelog
   - v0.1 :: First Release
         - Make the colors suck a lot less, and the buffers look a lot nicer.
   - v0.1.1 :: [2014-01-06]
     - Fix checkboxes
   - v0.1.2 :: [2014-01-06]
     - Add Verdana font to fall back on
   - v0.2 [2016-08-08]
     - Better repository Location
     - Fix so that you can load the theme properly.

**** Road map
   - Future
     - Figure out a better sub-theme infrastructure, so new themes don't break.
     - Work on niceifying todo keywords
         - Better color customizations
         - Look into alternate font settings
         - Iconficiations?
         - Look at making headlines span the full line, and make an org-mode pull request if required
     - Controllable Properties Need to look into this: [[info:elisp#Specified%20Space][info:elisp#Specified Space]]

**** Beautification
I Like Lucia Grande, so we'll start with that for a sans-serif font, but also allow for fall-backs.

For now the beautification is:
- Reset all headlines to the base background/foreground color
- Add padding around Headlines between levels 1 through 3
- Make headline level 2 and 1 bigger and sans-serif.
- Delineate the blocks nicely, and reset their foreground and background
- Set the foreground and background color of the checkboxes and make them very checkboxy
- strike through done keywords.
- Nicer Todo/Done states

**** The Code
#+begin_src emacs-lisp :tangle no
  (let* ((sans-font (cond ((x-list-fonts "Lucida Grande") '(:font "Lucida Grande"))
                          ((x-list-fonts "Verdana") '(:font "Verdana"))
                          ((x-family-fonts "Sans Serif") '(:family "Sans Serif"))
                          (nil (warn "Cannot find a Sans Serif Font.  Please report at: https://github.com/jonnay/org-beautify-theme/issues"))))
         (base-font-color (face-foreground 'default  nil 'default))
         (background-color (face-background 'default nil 'default))
         (headline `(:inherit default :foreground ,base-font-color))
         (primary-color (face-foreground 'mode-line nil))
         (secondary-color (face-background 'secondary-selection nil 'region))
         (padding `(:line-width 5 :color ,background-color))
         (org-highlights `(:foreground ,base-font-color :background ,secondary-color)))
    (custom-theme-set-faces 'org-beautify
                            `(org-agenda-structure ((t (:inherit default ,@sans-font :height 2.0 :underline nil))))
                            `(org-level-8 ((t ,headline)))
                            `(org-level-7 ((t ,headline)))
                            `(org-level-6 ((t ,headline)))
                            `(org-level-5 ((t ,headline)))
                            `(org-level-4 ((t ,headline)))
                            `(org-level-3 ((t (,@headline  :box ,padding))))
                            `(org-level-2 ((t (,@headline ,@sans-font :height 1.25 :box ,padding))))
                            `(org-level-1 ((t (,@headline ,@sans-font :height 1.5 :box ,padding ))))
                            `(org-document-title ((t (:inherit org-level-1 :height 2.0 :underline nil :box ,padding))))

                            `(org-block ((t (:foreground ,base-font-color :background ,background-color :box nil))))
                            `(org-block-begin-line ((t ,org-highlights)))
                            `(org-block-end-line ((t ,org-highlights)))

                            `(org-checkbox ((t (:foreground "#000000", :background "#93a1a1" :box (:line-width -3 :color "#93a1a1" :style "released-button")))))

                            `(org-headline-done ((t (:strike-through t))))
                            `(org-done ((t (:strike-through t))))))
#+end_src


#+begin_src emacs-lisp :tangle no

  (font-lock-add-keywords
   'org-mode '(("^\*+ \\(NEXT\\)"
                (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                          "❇\t N\tE\tX\tT\t"
                          nil)))))
#+end_src

**** NEXT <-- test a todo keyword On a headline
**** Display Testing
***** fourth
****** fifth
******* sixth
******** seventh
********* eighth
********** NINTH (this shows brokenness)
                 - list item
                 - [X] Checkbox
                 - [ ] Empty checkbox
**** TODO foo
**** DONE foo test
**** TODO The end of civilization
         SCHEDULED: <2031-01-19 Sun 03:14>
**** DONE Y2k
         CLOSED: [2000-01-01 00:00]
        :PROPERTIES:
        :FOO:      bar
        :END:
| Table |
|-------|
| row   |
| row   |

#+begin_example
this is an example
#+end_example

**** TODO Calendar

  While not strictly org mode, the Calendar and diary is tightly integrated.

  Color Scheme 1 is going to be medium-light gray for the main
  entries, Black for today, and off-gray for the special entries.

  The following Faces are available:
  - Calendar Today Face
  - Diary Anniversary
  - Diary Button
  - Diary
  - Diary Time
  - Holiday

  Note that the calendar actually uses the standard font lock
  keywords to customize the look of the main area. I am not entirely
  sure how to change that, without changing it for all buffers.

  - Weenend :: font-lock-comment-face
  - Weekday :: font-lock-constant-face
  - Month/year :: font-lock-function-face

**** Developing

~describe-text-properties~ is your friend

**** Testing

  Run this chunk of lisp to test the theme:

#+begin_src emacs-lisp :tangle no
  (progn
    (when (file-exists-p "org-beautify-theme.el")
      (delete-file "org-beautify-theme.el"))
    (org-babel-tangle-file "org-beautify-theme.org")
    (unless (member default-directory custom-theme-load-path)
      (add-to-list 'custom-theme-load-path default-directory))
    (when (member 'org-beautify 'custom-enabled-themes)
      (disable-theme 'org-beautify))
    (load-theme 'org-beautify))
#+end_src

**** Fin
#+begin_src emacs-lisp :tangle no
(provide-theme 'org-beautify)
;;; org-beautify-theme.el ends here
#+end_src

** actual theme
#+begin_src emacs-lisp
  ;(load-theme 'org-beautify)
  (load-theme 'noctilux)
#+end_src

** rainbow-identifiers

#+begin_src emacs-lisp
  (use-package rainbow-identifiers
    :ensure t
    :config
    ;; (add-hook 'prog-mode-hook 'rainbow-identifiers-mode)
)
#+end_src

** rainbow-mode
This minor mode sets background color to strings that match color
names, e.g. #0000ff is displayed in white with a blue background.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-mode)
#+end_src

** org-bullets

[[https://github.com/sabof/org-bullets][org-bullets]] show org-mode bullets as UTF-8 characters.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

** gists
https://github.com/defunkt/gist.el

view and edit my gists from emacs.
#+begin_src emacs-lisp :tangle no
  (use-package gist
    :ensure t)
#+end_src

** yasnippet
[[https://github.com/capitaomorte/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function templates.

[[https://github.com/emacs-jp/helm-c-yasnippet][helm-c-yasnippet]] is a helm source to display available yasnippets for the
current mode.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :defer 5
    ;; :diminish yas-minor-mode
    ;; :init (add-hook 'prog-mode-hook #'yas-minor-mode)
    :config (progn
              (yas-global-mode 1)
              (yas-reload-all)))

  (use-package auto-yasnippet
    :ensure t
    :config
    (progn
      ;; (yas-load-directory "<path>/<to>/snippets/")
      ))


  ;; maintained seperately - AndreaCrotti
  (use-package yasnippet-snippets
    :ensure t
    )
#+END_SRC

aya's open line or yas-expand.

#+begin_src emacs-lisp
(global-set-key "\C-o" 'aya-open-line)

(defun aya-open-line ()
  "Call `open-line', unless there are abbrevs or snippets at point.
In that case expand them.  If there's a snippet expansion in progress,
move to the next field. Call `open-line' if nothing else applies."
  (interactive)
  (cond ((expand-abbrev))

        ((yas--snippets-at-point)
         (yas-next-field-or-maybe-expand))

        ((ignore-errors
           (yas/expand)))

        (t
         (open-line 1))))

#+end_src

aya-open-line from auto-yasnippet does more than a plain open-line:
- it tries to expand abbrevs
- it tries to move to the next field of yasnippet
- it tries to expand yasnippet
- finally, it calls open-line if all else fails

http://emacs.stackexchange.com/questions/7908/how-to-make-yasnippet-and-company-work-nicer

** Ivy
Abo-abo, thank you.
http://oremacs.com/

#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :diminish ivy-mode
    :config
    ;; from the readme
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-t" 'swiper)
    ;; (global-set-key "\C-f" 'forward-char)  ;; replacement for c-f
    (global-set-key "\M-t" 'forward-word)  ;; ..
    (global-set-key (kbd "C-c u") 'swiper-all)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "<f6>") 'ivy-resume)

    ;; replace buffer search
    (bind-keys :map swiper-map
               ("<escape>" . minibuffer-keyboard-quit))
    (bind-keys :map ivy-minibuffer-map
               ("<escape>" . minibuffer-keyboard-quit)
               ("C-k"      . delete-minibuffer-contents))


    (use-package counsel
      :ensure t
      :config
      ;; what is this? Completion-in-region-function?
      (setq completion-in-region-function 'ivy-completion-in-region) ; this is good, might be interfering with python-mode and others
      ;;
      ;; Fuzzy matching
      ;;
      ;; http://oremacs.com/2016/01/06/ivy-flx/
      ;; (setq ivy-re-builders-alist
      ;;      '((t . ivy--regex-plus)))
      ;;    ; '((t . ivy--regex-fuzzy)))
      ;; You can also mix the two regex builders, for example:
      ;; (The t key is used for all fall-through cases, otherwise the key is the command or collection name.)
      (setq ivy-re-builders-alist
            '((swiper . ivy--regex-plus)
              (counsel-ag . ivy--regex-plus)
              (t . ivy--regex-fuzzy)))
      ;; If you're going fuzzy all the way, you can do without the initial ^ ,
      ;; and simply let flx (hopefully) sort the matches in a nice way:
      (setq ivy-initial-inputs-alist nil)

      (global-set-key (kbd "M-x") 'counsel-M-x)
      (global-set-key (kbd "C-.") 'counsel-M-x)
      (global-set-key (kbd "C-x C-f") 'counsel-find-file)
      ; (global-set-key (kbd "C-x b") 'switch-to-buffer)  ;; doesn't need to be specified unless overwritten by helm

      (global-set-key (kbd "<f1> f") 'counsel-describe-function)
      (global-set-key (kbd "<f1> b") 'counsel-descbinds)
      (global-set-key (kbd "C-x C-h") 'counsel-descbinds)
      (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
      (global-set-key (kbd "<f1> l") 'counsel-load-library)
      (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
      (global-set-key (kbd "<f2> u") 'counsel-unicode-char)

      (global-set-key (kbd "C-c k") 'counsel-ag)
      (global-set-key (kbd "C-c a") 'counsel-ag)
      (global-set-key (kbd "C-x l") 'counsel-locate)
      (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)

      (global-set-key (kbd "C-x C-o") 'counsel-git)
      (global-set-key (kbd "C-x C-p") 'counsel-git)
      (global-set-key (kbd "C-c j") 'counsel-git-grep)

      )

    (use-package flx   ; fuzzy matching/highlighting
      :ensure t)
    )

#+end_src

** Avy
https://github.com/abo-abo/avy

#+begin_src emacs-lisp
    (use-package avy
      :ensure t
      :config
      (avy-setup-default)
      (global-set-key (kbd "C-:") 'avy-goto-char)
      (global-set-key (kbd "C-'") 'avy-goto-char-2)
      (global-set-key (kbd "M-g f") 'avy-goto-line)
      (global-set-key (kbd "M-g w") 'avy-goto-word-1)
      (global-set-key (kbd "M-g e") 'avy-goto-word-0)

      (setq avy-keys-alist
            `((avy-goto-line-char2 . ,(number-sequence ?a ?w))
              (avy-goto-word-1 . (?a ?r ?s ?t ?n ?e ?i ?i))))

      (defun avy-goto-conditional ()
        "Jumping to conditionals in Elisp"
        (interactive)
        (avy--generic-jump "\\s(\\(if\\|cond\\|when\\|unless\\)\\b" nil 'pre))
      (global-set-key (kbd "M-g c") 'avy-goto-conditional)

      (defun avy-goto-paren ()
        "Jumping to an open paren"
        (interactive)
        (avy--generic-jump "(" nil 'pre))
      (global-set-key (kbd "M-g p") 'avy-goto-paren)

    )
#+end_src

** Helm

[[https://github.com/emacs-helm/helm][Helm]] is an Emacs incremental completion and selection narrowing framework.

[[https://github.com/emacs-helm/helm-descbinds][Helm descbinds]] provides an interface to emacs' =describe-bindings= making the
currently active key bindings interactively searchable with helm.

| Binding | Call              | Do                  |
|---------+-------------------+---------------------|
| C-h b   | describe-bindings | Show helm-descbinds |
| C-x C-h | describe-bindings | Show heml-descbinds |
|---------+-------------------+---------------------|


[[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]] list match lines to another buffer, which is able to squeeze by any
words you input. At the same time, the original buffer's cursor is jumping line
to line according to moving up and down the line list.

[[https://github.com/syohex/emacs-helm-themes][helm-themes]] provides theme selection with Helm.

#+begin_src emacs-lisp
  ;; All-in helm keybinds
;  (global-set-key (kbd "M-x") 'helm-M-x)
;  (global-set-key (kbd "C-.") 'helm-M-x)
;  (global-set-key (kbd "C-x C-f") 'helm-find-files)
;  (global-set-key (kbd "C-h a") 'helm-apropos)
;  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
;  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-c h o") 'helm-occur)
  (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
  (global-set-key (kbd "C-c h g") 'helm-google-suggest)
  (global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package helm
               :ensure t
               :diminish helm-mode
               :config
               (progn
                 (require 'helm-config)
                 (setq
                  helm-surfraw-duckduckgo-url "https://duckduckgo.com/lite/?q=!%s&kip=1"
                  helm-idle-delay 0.0
                  helm-input-idle-delay 0.01
                  helm-quick-update t
                  helm-M-x-requires-pattern nil
                  helm-M-x-fuzzy-match t
                  helm-buffers-fuzzy-matching t
                  helm-recentf-fuzzy-match t
                  helm-semantic-fuzzy-match t
                  helm-imenu-fuzzy-match t
                  helm-locate-fuzzy-match t
                  helm-ff-skip-boring-files t)

                 (global-set-key (kbd "C-h a") 'helm-apropos)

                 ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
                 ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
                 ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
                 (global-set-key (kbd "C-c h") 'helm-command-prefix)
                 (global-unset-key (kbd "C-x c"))

                 (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
                 (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
                 (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

                 (define-key helm-map (kbd "C-w")  'backward-kill-word) ; the default is "Yank symbol at point from helm-current-buffer" - wth?!

                 (when (executable-find "curl")
                   (setq helm-google-suggest-use-curl-p t))

                 (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
                       helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
                       helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
                       helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
                       helm-ff-file-name-history-use-recentf t
                       helm-display-header-line nil)

                 (set-face-attribute 'helm-source-header nil :height 0.1)

                 (setq helm-autoresize-max-height 0)
                 (setq helm-autoresize-min-height 25)
                 (helm-autoresize-mode 1)

                 (helm-mode 1)
                 )

               (use-package helm-c-yasnippet
                            :ensure t
                            :config (progn
                                      (global-set-key (kbd "C-c y") 'helm-yas-complete)
                                      (setq helm-yas-space-match-any-greedy t)))

               (use-package helm-descbinds
                            ;; counsel-descbinds
                            :ensure t
                            :config
                            (helm-descbinds-mode t)
                            (setq helm-descbinds-window-sytle 'split-window))

               (use-package helm-swoop
                            ;; counsel-swiper
                            :pin melpa-stable
                            :commands (helm-swoop helm-multi-swoop))

               (use-package helm-themes
                            ;; counsel-themes
                            :commands helm-themes)
  )
#+END_SRC

Eshell goodies - need to play with this before I decide.
#+begin_src emacs-lisp
  ;; eshell goodies
  (add-hook 'eshell-mode-hook
            (lambda ()
              (eshell-cmpl-initialize)
              (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
              (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history)))

  (defun pcomplete/sudo ()
    (let ((prec (pcomplete-arg 'last -1)))
      (cond ((string= "sudo" prec)
             (while (pcomplete-here*
                     (funcall pcomplete-command-completion-function)
                     (pcomplete-arg 'last) t))))))

  (defun pcomplete/find ()
    (let ((prec (pcomplete-arg 'last -1)))
      (cond ((and (pcomplete-match "^-" 'last)
                  (string= "find" prec))
             (pcomplete-opt "HLPDO"))
            ((pcomplete-match "^-" 'last)
             (while (pcomplete-here
                     '("-amin" "-anewer" "-atime" "-cmin" "-cnewer" "-context"
                       "-ctime" "-daystart" "-delete" "-depth" "-empty" "-exec"
                       "-execdir" "-executable" "-false" "-fls" "-follow" "-fprint"
                       "-fprint0" "-fprintf" "-fstype" "-gid" "-group"
                       "-help" "-ignore_readdir_race" "-ilname" "-iname"
                       "-inum" "-ipath" "-iregex" "-iwholename"
                       "-links" "-lname" "-ls" "-maxdepth"
                       "-mindepth" "-mmin" "-mount" "-mtime"
                       "-name" "-newer" "-nogroup" "-noignore_readdir_race"
                       "-noleaf" "-nouser" "-nowarn" "-ok"
                       "-okdir" "-path" "-perm" "-print"
                       "-print0" "-printf" "-prune" "-quit"
                       "-readable" "-regex" "-regextype" "-samefile"
                       "-size" "-true" "-type" "-uid"
                       "-used" "-user" "-version" "-warn"
                       "-wholename" "-writable" "-xdev" "-xtype"))))
            ((string= "-type" prec)
             (while (pcomplete-here (list "b" "c" "d" "p" "f" "l" "s" "D"))))
            ((string= "-xtype" prec)
             (while (pcomplete-here (list "b" "c" "d" "p" "f" "l" "s"))))
            ((or (string= prec "-exec")
                 (string= prec "-execdir"))
             (while (pcomplete-here* (funcall pcomplete-command-completion-function)
                                     (pcomplete-arg 'last) t))))
      (while (pcomplete-here (pcomplete-entries) nil 'identity))))

#+end_src

** TODO sublimity
what is this? sublime keybinds?
#+begin_src emacs-lisp :tangle no
  (use-package sublimity
    :ensure t
    :config
    (progn
      ;; (sublimity-map-set-delay 5)
      (setq sublimity-map-size 20)
      (setq sublimity-map-fraction 0.3)
      (setq sublimity-map-text-scale -7)
      (add-hook 'sublimity-map-setup-hook
            (lambda ()
              (setq buffer-face-mode-face '(:family "Monospace"))
              (buffer-face-mode)))
      )
  )
#+end_src

** TODO smartparens
https://github.com/Fuco1/smartparens

#+begin_src emacs-lisp :tangle no
  (use-package smartparens
    :ensure t
    :pin melpa-stable
    :diminish smartparens-mode
    :config
    (progn
      (require 'smartparens-config)
      (smartparens-global-mode t)))
#+end_src

** paredit
#+begin_src emacs-lisp
  (use-package paredit
    :pin melpa-stable
    :ensure t
    :config
      (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
      (add-hook 'emacs-lisp-mode-hook                     #'enable-paredit-mode)
      (add-hook 'eval-expression-minibuffer-setup-hook    #'enable-paredit-mode)
      (add-hook 'ielm-mode-hook                           #'enable-paredit-mode)
      (add-hook 'lisp-mode-hook                           #'enable-paredit-mode)
      (add-hook 'lisp-interaction-mode-hook               #'enable-paredit-mode)
      (add-hook 'clojure-mode-hook                        #'paredit-mode)
      (add-hook 'scheme-mode-hook                         #'enable-paredit-mode))
#+end_src
** paredit-everywhere
#+begin_src emacs-lisp
  (use-package paredit-everywhere
    :pin melpa-stable
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'paredit-everywhere-mode))
#+end_src

** emacs_chrome (edit-server)
https://github.com/stsquad/emacs_chrome

It starts a edit-server on 127.0.0.1:9292 by default

This provides an edit server to respond to requests from the Chrome
Emacs Chrome plugin. This is my first attempt at doing something
with sockets in Emacs. I based it on the following examples:

  http://www.emacswiki.org/emacs/EmacsEchoServer
  http://nullprogram.com/blog/2009/05/17/

To use it ensure the file is in your load-path and add something
like the following examples to your .emacs:

To open pages for editing in new buffers in your existing Emacs
instance:

  (when (require 'edit-server nil t)
    (setq edit-server-new-frame nil)
    (edit-server-start))

To open pages for editing in new frames using a running emacs
started in --daemon mode:

  (when (and (require 'edit-server nil t) (daemonp))
    (edit-server-start))

Buffers are edited in `text-mode' by default; to use a different
major mode, change `edit-server-default-major-mode' or customize
`edit-server-url-major-mode-alist' to specify major modes based
on the remote URL:

  (setq edit-server-url-major-mode-alist
        '(("github\\.com" . markdown-mode)))

Alternatively, set the mode in `edit-server-start-hook'.  For
example:

(add-hook 'edit-server-start-hook
         (lambda ()
           (when (string-match "github.com" (buffer-name))
             (markdown-mode))))

#+begin_src emacs-lisp
(use-package edit-server
  :ensure t
  :config
  (edit-server-start))
#+end_src

** xkcd
#+begin_src emacs-lisp
  (use-package xkcd
    :ensure t)
  ;; (xkcd) ; load at startup
#+end_src

** mingus
Music player. Control MPD from emacs.

#+begin_src emacs-lisp
  (use-package mingus
    :ensure t
    )

#+end_src

** StackOverflow Search (sos)
stack overflow searches delivered as an org file. awesome.

#+begin_src emacs-lisp
(use-package sos
  :ensure t)
#+end_src

** gnus
news and imap.
Todo:
- offline imap -  [[http://sachachua.com/blog/2008/05/geek-how-to-use-offlineimap-and-the-dovecot-mail-server-to-read-your-gmail-in-emacs-efficiently/][sacha does this]]
- weeheft@gmail.com
- [[https://github.com/abo-abo/hydra][hydra]] would actually be helpful here
- grok gnus, expiries, the universe, and everything
- what about searching?
- contact syncing and company-mode completion
- [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org][Practical guide to use Gnus with Gmail]]
- [[https://www.gnu.org/software/emacs/manual/html_node/gnus/Comparing-Mail-Back-Ends.html][comparing backends]]
- [[https://www.gnu.org/software/emacs/manual/html_node/gnus/Expiring-Mail.html][gnu.org expiring mail]]
- [[http://stackoverflow.com/questions/4982831/i-dont-want-to-expire-mail-in-gnus][I don't want my mail to expire]]!!


#+begin_src emacs-lisp
  (require 'nnir)

  ;; @see http://www.emacswiki.org/emacs/GnusGmail#toc1
  (setq gnus-select-method '(nntp "news.gmane.org")) ;; if you read news groups

  ;; ask encryption password once
  (setq epa-file-cache-passphrase-for-symmetric-encryption t)

  ;; GMAIL IMAP
  ;; (add-to-list 'gnus-secondary-select-methods
  ;;              '(nnimap "gmail"
  ;;                       (nnimap-address "imap.gmail.com")
  ;;                       (nnimap-server-port 993)
  ;;                       (nnimap-stream ssl)
  ;;                       (nnir-search-engine imap)
  ;;                                         ; @see http://www.gnu.org/software/emacs/manual/html_node/gnus/Expiring-Mail.html
  ;;                       ;; press 'E' to expire email
  ;;                       (nnfolder-inhibit-expiry t)))

  ;; In /etc/dovecot/conf.d/10-mail.conf set the following, maybe?
  ;; mail_location = maildir:~/Maildir:LAYOUT=fs
  ;(add-to-list 'gnus-secondary-select-methods
  (setq gnus-select-method
        '(nnimap "dovecot"
                 (nnimap-stream shell)
                 (nnimap-shell-program "/usr/lib/dovecot/imap -o mail_location=maildir:~/Maildir/:LAYOUT=fs")))

  (setq user-mail-address "jesse.haubrich@gmail.com"
        ;; gnus-ignored-from-addresses "jesse.haubrich"  ;; regex for self
        gnus-ignored-mime-types (quote ("application/x-pkcs7-signature" "application/ms-tnef" "text/x-vcard"))
        )

  ;; Setup to send email through SMTP
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-local-domain "flexo")



  (defun my-gnus-group-list-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 5))

  (define-key gnus-group-mode-map
    ;; list all the subscribed groups even they contain zero un-read messages
    (kbd "o") 'my-gnus-group-list-subscribed-groups)


  ;; Summary Customization - https://www.emacswiki.org/emacs/GnusFormatting
  ;; Date and unicode threading
  (setq gnus-summary-line-format "%U%R%z %(%&user-date;  %-23,23f  %B%s%)\n"
        gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
        gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
        gnus-thread-sort-functions '(gnus-thread-sort-by-date)
        gnus-sum-thread-tree-false-root ""
        gnus-sum-thread-tree-indent " "
        gnus-sum-thread-tree-leaf-with-other "├► "
        gnus-sum-thread-tree-root ""
        gnus-sum-thread-tree-single-leaf "╰► "
        gnus-sum-thread-tree-vertical "│")
#+end_src

** mu4

This config has been mostly working for me. Joe has something far more tweaked.

- =html2text= is not working (using wm3)
- =offlineimap= hangs
- config is a bit of a mess. [[http://www.macs.hw.ac.uk/~rs46/posts/2014-01-13-mu4e-email-client.html][This one]] is cleaner. (he uses mbsync).

- [[https://github.com/fgallina/mu4e-multi][mu4e-multi]] looks like a good altenative configuration
- [[http://tech.memoryimprintstudio.com/?p=262][Here]] are some instructions for replacing =offlineimap= with =procmail=, and
  setting up spam filtering and antivirus.

=mu4e= is a nifty email client. It accesses a folder with standard mbox (?) so you
need another app to retrieve mail. I've been using [[https://wiki.archlinux.org/index.php/OfflineIMAP][offlineimap]], but it hangs
on suspend and is damn slow.

It isn't available in melpa (Jun 2015), but is in the AUR.

    $ yaourt mu-git
    $ yaourt offlineimap



This configuration was borrowed wholesale from [[http://www.djcbsoftware.nl/code/mu/mu4e/Gmail-configuration.html#Gmail-configuration][the help file on gmail]].

#+BEGIN_src emacs-lisp :tangle no
    (when (display-graphic-p)
    (require 'mu4e)
    (when (not (featurep 'mu4e))
      (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/"))
    (require 'smtpmail)

    (if (string< emacs-version "24")
        (setq message-send-mail-function 'smtpmail-send-it
              starttls-use-gnutls t
              smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
              smtpmail-auth-credentials
              '(("smtp.gmail.com" 587 "jesse.haubrich@gmail.com" nil))
              smtpmail-default-smtp-server "smtp.gmail.com"
              smtpmail-smtp-server "smtp.gmail.com"
              smtpmail-smtp-service 587)

      ;; alternatively, for emacs-24 you can use:
      (setq message-send-mail-function 'smtpmail-send-it
            smtpmail-stream-type 'starttls
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 587)
      )

    ;; defaults
    (setq mu4e-maildir "~/Maildir/")
    (setq mu4e-drafts-folder "/[Gmail].Drafts")
    (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
    (setq mu4e-trash-folder  "/[Gmail].Trash")

    ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
    (setq mu4e-sent-messages-behavior 'delete)

    ;; setup some handy shortcuts
    ;; you can quickly switch to your Inbox -- press ``ji''
    ;; then, when you want archive some messages, move them to
    ;; the 'All Mail' folder by pressing ``ma''.
    (setq mu4e-maildir-shortcuts
          '( ("/Inbox"               . ?i)
             ("/[Gmail].IMPORTANT"   . ?!)
             ("/[Gmail].Sent Mail"   . ?s)
             ("/[Gmail].Trash"       . ?t)
             ("/[Gmail].All Mail"    . ?a)))

    ;; allow for updating mail using 'U' in the main view:
    (setq mu4e-get-mail-command "offlineimap")

    ;; something about ourselves
    (setq
     user-mail-address "jesse.haubrich@gmail.com"

     user-full-name  "Jesse Haubrich"
     message-signature nil)


    ;; don't keep message buffers around
    (setq message-kill-buffer-on-exit t)

    ;; show images
    (setq mu4e-show-images t)

    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

      ;;; message view action
    (defun mu4e-msgv-action-view-in-browser (msg)
      "View the body of the message in a web browser."
      (interactive)
      (let ((html (mu4e-msg-field (mu4e-message-at-point t) :body-html))
            (tmpfile (format "%s/%d.html" temporary-file-directory (random))))
        (unless html (error "No html part for this message"))
        (with-temp-file tmpfile
          (insert
           "<html>"
           "<head><meta http-equiv=\"content-type\""
           "content=\"text/html;charset=UTF-8\">"
           html))
        (browse-url (concat "file://" tmpfile))))

    (add-to-list 'mu4e-view-actions
                 '("View in browser" . mu4e-msgv-action-view-in-browser) t)

    ;; convert org mode to HTML automatically
    (setq org-mu4e-convert-to-html t)
    ;; need this to convert some e-mails properly
    ;; (setq mu4e-html2text-command "html2text -utf8 -width 72")
    ;; (setq mu4e-html2text-command "w3m -T text/html")
    (setq mu4e-view-prefer-html t)
    ;(setq mu4e-html2text-command "w3m -dump -cols 110 -T text/html")

    ;; program to convert to pdf
    (setq mu4e-msg2pdf "~/src/mu/toys/msg2pdf")

    ;; view email addresses not only the name
    (setq mu4e-view-show-addresses t)

    ;; attempt to show images when viewing messages
    (setq
     mu4e-view-show-images t
     mu4e-view-image-max-width 800)

    ;; use imagemagick if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    ;; use 'fancy' non-ascii characters in various places in mu4e
    (setq mu4e-use-fancy-chars nil) ;; breaks monospacing with my current font

    ;; do not ask for confirmation on exit
    (setq mu4e-confirm-quit  nil)

    ;; set mu4e as the default emacs email client
    (setq mail-user-agent 'mu4e-user-agent)

    ;; attempt to automatically retrieve public keys when needed
    (setq mu4e-auto-retrieve-keys t)

    ;; don't reply to myself
    (setq mu4e-compose-dont-reply-to-self t)

    ;; only personal messages get in the address book
    (setq mu4e-compose-complete-only-personal t)

    (add-hook 'mu4e-compose-mode-hook
              (lambda ()
                (turn-off-auto-fill)
                (visual-line-mode)))
    (remove-hook 'text-mode-hook 'turn-on-auto-fill)


    (use-package org-mu4e
      :config
      (progn
        (setq org-mu4e-convert-to-html t)
        (defalias 'org-mail 'org-mu4e-compose-org-mode)))
  )
#+END_SRC

*** Offlineimap config
Periodically get new mail, borrowed from the manual [[http://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html#Retrieval-and-indexing][here]], which also had some
tips on error handling (not implemented).

#+BEGIN_SRC emacs-lisp :tangle no
(setq
   mu4e-get-mail-command "offlineimap -q"
   mu4e-update-interval 300)             ;; update every 5 minutes
#+END_SRC

The offlineimap config file is at =~/.offlineimaprc=. Here is an example.

#+begin_src conf :tangle no
[general]
accounts = Gmail
maxsyncaccounts = 3

[Account Gmail]
localrepository = Local
remoterepository = Remote
#status_backend = sqlite  # plain

[Repository Local]
type = Maildir
localfolders = ~/Maildir

[Repository Remote]
type = Gmail
remotehost = imap.gmail.com
remoteuser = my_email@gmail.com
remotepass = my_app_password_from_google
ssl = yes
sslcacertfile = /etc/ssl/certs/ca-certificates.crt

realdelete = no
holdconnectionopen = true
keepalive = 60
maxconnections = 2
#+end_src

*** Sending emails asynchronous

This is useful to send emails with attachments and do not block emacs
until end the transmission.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smtpmail-async
    :config
    (setq
     send-mail-function 'async-smtpmail-send-it
     message-send-mail-function 'async-smtpmail-send-it))
#+END_SRC

*** TODO mu4e-maildirs-extension

[[https://github.com/agpchil/mu4e-maildirs-extension][Mu4e maildirs extension]] adds a maildir summary in mu4e-main-view.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package mu4e-maildirs-extension
    :ensure t
    :defer 0.8
    :config
    (progn
      (mu4e-maildirs-extension)
      (setq mu4e-maildirs-extension-maildir-separator    "*"
            mu4e-maildirs-extension-submaildir-separator "✉"
            mu4e-maildirs-extension-action-text          nil)))
#+END_SRC

** DONE golden-ratio
This seems really handy for a *small* laptop screen.
#+begin_src emacs-lisp
  (use-package golden-ratio
    :ensure t
    :diminish golden-ratio-mode
    :config
    (golden-ratio-mode 1)
    (setq golden-ratio-adjust-factor .8
          golden-ratio-wide-adjust-factor .8)

    (defun pl/helm-alive-p ()
      (if (boundp 'helm-alive-p)
          (symbol-value 'helm-alive-p)))

    (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)
    )
#+end_src
* Languages
#+begin_src emacs-lisp :tangle no
  (defun jhaus-coding-hook ()
    (make-local-variable 'column-number-mode)
    (column-number-mode t)
    ; (if display-graphic-p) (hl-line-mode t)) ;; sometimes annoying (lighten color?)
  )
  (add-hook 'emacs-lisp-mode-hook 'jhaus-coding-hook)
  (add-hook 'ruby-mode-hook 'jhaus-coding-hook)
  (add-hook 'python-mode-hook 'jhaus-coding-hook)
  (add-hook 'js2-mode-hook 'jhaus-coding-hook)
  (add-hook 'c-mode-hook 'jhaus-coding-hook)
#+end_src


** C++
Before using RTags you need to start rdm and index your project. In
order to index your project, RTags requires you to export your
project's compile commands with cmake.

$ rdm &
$ cd /path/to/project/root
$ cmake . -DCMAKE_EXPORT_COMPILE_COMMANDS=1
$ rc -J .

NOTE: Like RTags, Irony requires a compilation database. To create
one run the following:

$ cd /path/to/project/root
$ cmake . -DCMAKE_EXPORT_COMPILE_COMMANDS=1


#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'electric-pair-mode)
  (add-hook 'c-mode-hook 'electric-pair-mode)
  (add-hook 'objc-mode-hook 'electric-pair-mode)

  (use-package company-rtags
    :ensure t)

  (use-package rtags
    :ensure t
    :config (progn
              (setq rtags-completions-enabled t)
              (eval-after-load 'company
                '(add-to-list
                  'company-backends 'company-rtags))
              (setq rtags-autostart-diagnostics t)
              (rtags-enable-standard-keybindings)))

  (use-package helm-rtags
    :ensure t
    :config (setq rtags-use-helm t))




  (use-package irony
    :ensure t
    :config (progn
              (add-hook 'c++-mode-hook 'irony-mode)
              (add-hook 'c-mode-hook 'irony-mode)
              (add-hook 'objc-mode-hook 'irony-mode)

              (defun my-irony-mode-hook ()
                (define-key irony-mode-map [remap completion-at-point]
                  'irony-completion-at-point-async)
                (define-key irony-mode-map [remap complete-symbol]
                  'irony-completion-at-point-async))

              (add-hook 'irony-mode-hook 'my-irony-mode-hook)
              (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)))


  (use-package company-irony
    :ensure t
    :config (progn
              (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
              (setq company-backends (delete 'company-semantic company-backends))
              (eval-after-load 'company
                '(add-to-list
                  'company-backends 'company-irony-c-headers 'company-irony))))

  (use-package company-irony-c-headers
    :ensure t)


  (use-package flycheck-rtags
    :ensure t
    :config (progn
              (defun my-flycheck-rtags-setup ()
                (flycheck-select-checker 'rtags)
                (setq-local flycheck-highlighting-mode nil) ;; RTags creates more accurate overlays.
                (setq-local flycheck-check-syntax-automatically nil))
              ;; c-mode-common-hook is also called by c++-mode
              (add-hook 'c-mode-common-hook #'my-flycheck-rtags-setup)
              ))

  (use-package flycheck-irony
    :ensure t
    :config (progn
              (eval-after-load 'flycheck
                '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))))

  (use-package cmake-ide
    :ensure t
    :config (progn
              (cmake-ide-setup)
              (eval-after-load 'flycheck
                '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))))
#+end_src

** Clojure
#+begin_src emacs-lisp
  (use-package clojure-mode
    :ensure t
    :pin melpa-stable)

  (use-package cider
    :ensure t
    :pin melpa-stable)

  (use-package flycheck-clojure
    :ensure t
    :pin melpa-stable)

  ;; https://github.com/clojure-emacs/clj-refactor.el
  (use-package clj-refactor
    :ensure t
    :pin melpa-stable
    :config
    (defun my-clojure-mode-hook ()
      (yas-minor-mode 1) ; for adding require/use/import statements
      ;; This choice of keybinding leaves cider-macroexpand-1 unbound
      (cljr-add-keybindings-with-prefix "C-c C-m"))
    (add-hook 'clojure-mode-hook #'my-clojure-mode-hook))
#+end_src

** python
Get shell variables from terminal (gui session)
https://github.com/purcell/exec-path-from-shell

#+begin_src emacs-lisp :tangle no
(when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize))
(exec-path-from-shell-copy-env "PYTHONPATH")
#+end_src

*** elpy
https://github.com/jorgenschaefer/elpy
https://elpy.readthedocs.io/en/latest/ide.html

Elpy is an Emacs package to bring powerful Python editing to Emacs. It
combines and configures a number of other packages, both written in
Emacs Lisp as well as Python.

Dependencies:
- flake8 (yaourt python-flake8
- jedi (yaourt python-jedi)
- rope (yaourt rope)
- importmagic (pip)
- autopep8 (pip)
- yapf (pip)
- company (i think)

#+begin_src emacs-lisp
  (use-package pyvenv ; melpa-unstable?
    :ensure t
    :pin melpa-stable
    ;; set $WORKON_HOME in .zshrc
    ;; export WORKON_HOME="~/venv"
    )

  (use-package elpy
    :pin melpa-stable
    :ensure t
    :config
    (progn
      (package-initialize)
      (elpy-enable)
      (setq
       elpy-rpc-backend "jedi"  ;; defaults to ropes i think
       ;; elpy-rpc-project-specific t
       elpy-modules '(elpy-module-sane-defaults
                      ;; elpy-module-company
                      elpy-module-eldoc
                      elpy-module-flymake
                      ;; elpy-module-highlight-indentation
                      elpy-module-pyvenv
                      elpy-module-yasnippet
                      elpy-module-django)
       )))
#+end_src

Q: How to solve company, yasnippet conflicts?
A: Add this snippet to your emacs configuration to avoid that.
#+begin_src emacs-lisp :tangle no
(defun company-yasnippet-or-completion ()
  "Solve company yasnippet conflicts."
  (interactive)
  (let ((yas-fallback-behavior
         (apply 'company-complete-common nil)))
    (yas-expand)))

(add-hook 'company-mode-hook
          (lambda ()
            (substitute-key-definition
             'company-complete-common
             'company-yasnippet-or-completion
             company-active-map)))
#+end_src

*** TODO jedi

[[https://github.com/tkf/emacs-jedi][Jedi]] offers very nice auto completion for python-mode.

The first time you install jedi you will have to run =M-x jedi:install-server=.

This is not working in ipython. I had a fix in my old emacs. Also the timing is
terrible. I can't type fast enough to keep it from suggesting.

#+BEGIN_src emacs-lisp
  (use-package jedi
    :ensure t
    :defer t
    :init
    (add-hook 'python-mode-hook 'jedi:setup)
    (add-hook 'python-mode-hook 'jedi:ac-setup)
    :config
    (setq jedi:complete-on-dot t))
#+END_src

*** TODO ein

Lovely lovely ipython notebook in a familiar environment.

#+begin_src emacs-lisp :tangle no
  ;; ein
  (use-package ein
    :ensure t
    :config
    ;; (add-to-list 'load-path "~/.emacs.d/vendor/emacs-ipython-notebook")
    ;;(setq ein:use-auto-complete t)
    ;; Or, to enable "superpack" (a little bit hacky improvements):
    (setq ein:use-auto-complete-superpack t)
    (setq ein:use-smartrep t)
    ;; ein:smartrep-config: Symbol's function definition is void: smartrep-define-key
    )
#+end_src

I also like these color customizations with =Monokai=, but the code needs to be added to init.el, where it warns that if you have more than one instance of this it won't work right.

#+begin_src emacs-lisp :tangle no
  (custom-set-faces
   '(ein:cell-input-area ((t (:background "#272822"))))
   '(ein:cell-input-prompt ((t (:inherit header-line :background "#272822" :foreground "dimgray" :height 0.8))))
#+end_src

*** TODO virtualenvwrapper.el
Note: =virtualenvwrapper= is not in melpa-stable. <2015-11-15>

[[https://github.com/porterjamesj/virtualenvwrapper.el][venvwrapper.el]] provides a way to activate, deactivate, create, and
destroy python virtualenvs from emacs. It also makes eshell virtualenv
aware which was my primary concern.

Use =M-x venv-workon= to activate virtualenvs and =M-x
venv-deactivate= deactivate them.

#+begin_src emacs-lisp :tangle no
  (use-package virtualenvwrapper
    :ensure t
    :config
    (venv-initialize-interactive-shells) ;; if you want interactive shell support
    (venv-initialize-eshell) ;; if you want eshell support
    (setq venv-location "~/venv/")
    ;; add to modeline
    (setq-default mode-line-format (cons '(:exec venv-current-name) mode-line-format))
    ;; custom eshell prompt
    ;; (setq eshell-prompt-function
    ;;       (lambda ()
    ;;         (concat venv-current-name " $ ")))

    )

#+end_src

*** TODO run python3
#+begin_src emacs-lisp :tangle no
(defun run-python3 ()
  "."
  (interactive) (run-python "/usr/bin/ipython"))

;; trying ipython tab completion: that works :)
;; http://stackoverflow.com/questions/21880950/what-combination-of-python-mode-ipython-ipython-el-versions-releases-and-ini
(setq
 python-shell-interpreter "ipython"
 python-shell-interpreter-args ""
 python-shell-prompt-regexp "In \\[[0-9]+\\]: "
 python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
 python-shell-completion-setup-code "from IPython.core.completerlib import module_completion"
 python-shell-completion-module-string-code "';'.join(module_completion('''%s'''))\n"
 python-shell-completion-string-code "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
#+end_src

** lua

#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t)
#+end_src

** markdown-mode

[[http://jblevins.org/projects/markdown-mode/][markdown-mode]] is a major mode for editing Markdown-formatted text files in GNU
Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC

** yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode)))

#+end_src

** web-mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq coffee-tab-width 2)
    (setq javascript-indent-level 2)
    (setq js-indent-level 2)
    (setq js2-basic-offset 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq css-indent-offset 2)
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[gj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode)))
#+end_src

** TODO docker
[[https://github.com/emacs-pe/docker-tramp.el/blob/master/docker-tramp.el][docker-tramp]], and [[https://github.com/nlamirault/marcopolo][marcopolo]] look interesting. Will have to investigate later.

[[https://github.com/spotify/dockerfile-mode][Dockerfile-mode]] gets us some syntax highlighting and a bulid binding (C-c C-b) I
don't see myself using.

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+END_SRC

* Archive
This is code that is no longer used. Everything here should be set to =:tangle no=.
** TODO Load other files

#+BEGIN_SRC emacs-lisp :tangle no
  (defun load-if-exists (f)
    ""
    (if (file-readable-p f)
        (load-file f)))

  (load-if-exists "~/Dropbox/dotfiles/emacs/other_email_configs.el")
  (load-if-exists "~/Dropbox/dotfiles/emacs/not_for_github.el")
#+END_SRC

** TODO highlight indentation
https://github.com/antonj/Highlight-Indentation-for-Emacs/
** TODO saveplace

this is included with better defaults.

Save cursor position across sessions
Save the cursor position for every file you opened. So, next time you open the
file, the cursor will be at the position you last opened it.

#+begin_src emacs-lisp :tangle no
  (use-package saveplace
    :ensure t
    :config
    (progn
      (setq save-place-file "~/.emacs.d/saves/saveplace.el")
      (setq-default save-place t)))
#+end_src

** TODO multiterm
FIXME: Weird characters and linebreaks.

This code is copied from http://www.emacswiki.org/emacs/download/multi-term.el

#+begin_src emacs-lisp :tangle no
  ;;; multi-term.el --- Managing multiple terminal buffers in Emacs.

  ;; Author: Andy Stewart <lazycat.manatee@gmail.com>
  ;; Maintainer: Andy Stewart <lazycat.manatee@gmail.com>
  ;; Copyright (C) 2008, 2009, 2014 Andy Stewart, all rights reserved.
  ;; Copyright (C) 2010, ahei, all rights reserved.
  ;; Created: <2008-09-19 23:02:42>
  ;; Version: 1.3
  ;; Last-Updated: 2015-02-20 21:15:35
  ;; URL: http://www.emacswiki.org/emacs/download/multi-term.el
  ;; Keywords: term, terminal, multiple buffer
  ;; Compatibility: GNU Emacs 23.2.1, GNU Emacs 24.4 (and prereleases)

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; see the file COPYING.  If not, write to
  ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  ;; Floor, Boston, MA 02110-1301, USA.

  ;; Features that might be required by this library:
  ;;
  ;;  `term' `cl' `advice'
  ;;

  ;;; Commentary:
  ;;
  ;; This package is for creating and managing multiple terminal buffers in Emacs.
  ;;
  ;; By default, term.el provides a great terminal emulator in Emacs.
  ;; But I have some troubles with term-mode:
  ;;
  ;; 1. term.el just provides commands `term' or `ansi-term'
  ;;    for creating a terminal buffer.
  ;;    And there is no special command to create or switch
  ;;    between multiple terminal buffers quickly.
  ;;
  ;; 2. By default, the keystrokes of term.el conflict with global-mode keystrokes,
  ;;    which makes it difficult for the user to integrate term.el with Emacs.
  ;;
  ;; 3. By default, executing *NIX command "exit" from term-mode,
  ;;    it will leave an unused buffer.
  ;;
  ;; 4. term.el won't quit running sub-process when you kill terminal buffer forcibly.
  ;;
  ;; 5. Haven't a dedicated window for debug program.
  ;;
  ;; And multi-term.el is enhanced with those features.
  ;;

  ;;; Installation:
  ;;
  ;; Copy multi-term.el to your load-path and add to your ~/.emacs
  ;;
  ;;  (require 'multi-term)
  ;;
  ;; And setup program that `multi-term' will need:
  ;;
  ;; (setq multi-term-program "/bin/bash")
  ;;
  ;;      or setup like me "/bin/zsh" ;)
  ;;
  ;; Below are the commands you can use:
  ;;
  ;;      `multi-term'                    Create a new term buffer.
  ;;      `multi-term-next'               Switch to next term buffer.
  ;;      `multi-term-prev'               Switch to previous term buffer.
  ;;      `multi-term-dedicated-open'     Open dedicated term window.
  ;;      `multi-term-dedicated-close'    Close dedicated term window.
  ;;      `multi-term-dedicated-toggle'   Toggle dedicated term window.
  ;;      `multi-term-dedicated-select'   Select dedicated term window.
  ;;
  ;; Tips:
  ;;
  ;;      You can type `C-u' before command `multi-term' or `multi-term-dedicated-open'
  ;;      then will prompt you shell name for creating terminal buffer.
  ;;

  ;;; Customize:
  ;;
  ;; `multi-term-program' default is nil, so when creating new term buffer,
  ;; send environment variable of `SHELL' (`ESHELL', `/bin/sh') to `make-term'.
  ;;
  ;; And you can set it to your liking, like me: ;-)
  ;;
  ;; (setq multi-term-program "/bin/zsh")
  ;;
  ;; `multi-term-default-dir' default is `~/', only use when current buffer
  ;; is not in a real directory.
  ;;
  ;; `multi-term-buffer-name' is the name of term buffer.
  ;;
  ;; `multi-term-scroll-show-maximum-output' controls how interpreter
  ;; output causes window to scroll.
  ;;
  ;; `multi-term-scroll-to-bottom-on-output' controls whether interpreter
  ;; output causes window to scroll.
  ;;
  ;; `multi-term-switch-after-close' try to switch other `multi-term' buffer
  ;; after close current one.
  ;; If you don't like this feature just set it with nil.
  ;;
  ;; `term-unbind-key-list' is a key list to unbind some keystroke.
  ;;
  ;; `term-bind-key-alist' is a key alist that binds some keystroke.
  ;; If you don't like default, modify it.
  ;;
  ;; `multi-term-dedicated-window-height' the height of a dedicated term window.
  ;;
  ;; `multi-term-dedicated-max-window-height' the max height limit that dedicated
  ;; window is allowed.
  ;;
  ;; `multi-term-dedicated-skip-other-window-p' whether skip dedicated term
  ;; window when use command `other-window' to cycle windows order.
  ;;
  ;; All of the above can be customize by:
  ;;      M-x customize-group RET multi-term RET
  ;;

  ;;; Change log:
  ;;
  ;; 2015/02/20
  ;;      * Binding C-Backspace to `term-send-backward-kill-word' to follow emacs behaviour.
  ;;
  ;; 2014/12/04
  ;;      * Ernesto Rodriguez Reina <erreina@gmail.com>
  ;;      Fixed the bug of cursor not return to the position it was before opened the dedicated terminal window when
  ;;      `multi-term-dedicated-close-back-to-open-buffer-p' and `multi-term-dedicated-select-after-open-p' are t.
  ;;
  ;; 2014/08/27
  ;;      * Kevin Peng <kkpengboy@gmail.com>
  ;;      Keep multi-term buffer list make multi-term-next/prev can switch temrinal buffer even terminal buffer's name is changed.
  ;;
  ;; 2014/07/21
  ;;      * Andy Stewart
  ;;      Bind C-m with `term-send-return' instead `term-send-input' to fixed bug that
  ;;      duplicate input when you C-a and C-m in terminal.
  ;;
  ;; 2014/06/21
  ;;      * Fixed bug that can't found define of `multi-term-dedicated-handle-other-window-advice'.
  ;;
  ;; 2014/05/12
  ;;      * Make Emacs 24.4 compatibility cleaner by avoiding version sniffing.
  ;;
  ;; 2014/03/23
  ;;      * Add `term-send-esc' and binding with 'C-c C-e', send esc is useful for some program, such as vim. ;)
  ;;      * Add new option `multi-term-dedicated-close-back-to-open-buffer-p' .
  ;;      * Bind C-y with `term-paste' to avoid paste content can't insert in term mode.
  ;;
  ;; 2014/03/17   Andy Stewart
  ;;      * Swap key binding of `term-send-raw' and `term-send-input', i think it's better send yank data when user hit ctrl+m.
  ;;
  ;; 2014/01/16
  ;;      * Fix breakage introduced in Emacs 24.4.
  ;;
  ;; 2013/01/08
  ;;      * Fix customize group of `multi-term-try-create'.
  ;;      * Add autoloads.
  ;;      * Add new commands `term-send-quote' and `term-send-M-x'.
  ;;
  ;; 2009/07/04
  ;;      * Add new option `multi-term-dedicated-select-after-open-p'.
  ;;
  ;; 2009/06/29
  ;;      * Fix regexp bug.
  ;;
  ;; 2009/04/21
  ;;      * Fix a bug that bring at `2009/03/28':
  ;;        It will kill sub-process in other multi-term buffer
  ;;        when we kill current multi-term buffer.
  ;;
  ;; 2009/03/29
  ;;      * Add new command `term-send-reverse-search-history'.
  ;;
  ;; 2009/03/28
  ;;      * Add new option `multi-term-switch-after-close'.
  ;;
  ;; 2009/02/18
  ;;      * Fix bug between ECB and `multi-term-dedicated-close'.
  ;;
  ;; 2009/02/05
  ;;      * Prompt user shell name when type `C-u' before command
  ;;        `multi-term' or `multi-term-dedicated-open'.
  ;;      * Fix doc.
  ;;
  ;; 2009/01/29
  ;;      * Use `term-quit-subjob' instead `term-interrupt-subjob'.
  ;;      * Fix doc.
  ;;
  ;; 2009/01/13
  ;;      * Rewrite advice for `pop-to-buffer' to avoid `pop-to-buffer' not effect
  ;;        when have many dedicated window in current frame.
  ;;      * Rewrite advice for `delete-other-windows' to avoid use common variable
  ;;        `delete-protected-window-list' and use `window-dedicated-p' instead.
  ;;        Remove variable `delete-protected-window-list' and function
  ;;        `multi-term-dedicated-match-protected-window-p'.
  ;;
  ;; 2009/01/06
  ;;      * Improve document.
  ;;
  ;; 2008/12/29
  ;;      * Remove option `multi-term-current-window-height' and
  ;;        function `multi-term-current-directory'.
  ;;      * Add some functions to make get dedicated term buffer,
  ;;        those functions is beginning with `multi-term-dedicated-'.
  ;;      * Modified advice `delete-window', make command `delete-window'
  ;;        and delete dedicated window, but will remember window height
  ;;        before deleted.
  ;;      * Don't remember dedicated window height if larger than max value.
  ;;      * Fix some bug with `delete-other-windows' and window configuration.
  ;;        And this bug exists with another extension `sr-speedbar'.
  ;;      * Add new variable `delete-protected-window-list' for protected
  ;;        special window that won't be deleted.
  ;;        This variable is common for any extension that use dedicated
  ;;        window.
  ;;      * Fix doc.
  ;;
  ;; 2008/12/21
  ;;      * Default bind `C-m' with `term-send-input'.
  ;;
  ;; 2008/12/10
  ;;      * Improve customize interface.
  ;;      * Setup customize automatically, don't need to user setup it up.
  ;;      * Add option `multi-term-try-create'.
  ;;      * Make function `multi-term-switch' accept offset argument.
  ;;      * Fix doc.
  ;;
  ;; 2008/10/22
  ;;      * Add variable `multi-term-current-window-height'.
  ;;      * Add variable `multi-term-buffer-name'.
  ;;      * Add variable `term-unbind-key-list'.
  ;;      * Add variable `term-rebind-key-alist'.
  ;;      * Move key setup and some extension from `term-extension.el'.
  ;;      * Create new function `multi-term-keystroke-setup'.
  ;;      * Fix doc.
  ;;
  ;; 2008/09/19
  ;;      * First released.
  ;;

  ;;; Acknowledgments:
  ;;
  ;;      Mark Triggs     <mst@dishevelled.net>
  ;;              For create multi-shell.el
  ;;      Aaron S. Hawley <aaron.s.hawley@gmail.com>
  ;;              For improve document.
  ;;

  ;;; Bug
  ;;
  ;;

  ;;; TODO
  ;;
  ;;
  ;;

  ;;; Require:
  (require 'term)
  (require 'cl)
  (require 'advice)

  ;;; Code:

  ;;; Customize

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Customize ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defgroup multi-term nil
    "Multi term manager."
    :group 'term)

  (defcustom multi-term-program nil
    "The program of term.
  If this is nil, setup to environment variable of `SHELL'."
    :type 'string
    :group 'multi-term)

  (defcustom multi-term-program-switches nil
    "The command-line switches to pass to the term program."
    :type 'string
    :group 'multi-term)

  (defcustom multi-term-try-create t
    "Try to create a new term buffer when switch.

  When use `multi-term-next' or `multi-term-prev', switch term buffer,
  and try to create a new term buffer if no term buffers exist."
    :type 'boolean
    :group 'multi-term)

  (defcustom multi-term-default-dir "~/"
    "The default directory for terms if current directory doesn't exist."
    :type 'string
    :group 'multi-term)

  (defcustom multi-term-buffer-name "terminal"
    "The buffer name of term buffer."
    :type 'string
    :group 'multi-term)

  (defcustom multi-term-scroll-show-maximum-output nil
    "*Controls how interpreter output causes window to scroll.
  If non-nil, then show the maximum output when the window is scrolled.

  See variable `multi-term-scroll-to-bottom-on-output'."
    :type 'boolean
    :group 'multi-term)

  (defcustom multi-term-scroll-to-bottom-on-output nil
    "*Controls whether interpreter output causes window to scroll.
  If nil, then do not scroll.  If t or `all', scroll all windows showing buffer.
  If `this', scroll only the selected window.
  If `others', scroll only those that are not the selected window.

  The default is nil.

  See variable `multi-term-scroll-show-maximum-output'."
    :type 'boolean
    :group 'multi-term)

  (defcustom multi-term-switch-after-close 'NEXT
    "Try to switch other `multi-term' buffer after close current one.
  If this option is 'NEXT, switch to next `multi-term' buffer;
  If this option is 'PREVIOUS, switch to previous `multi-term' buffer.
  If this option is nil, don't switch other `multi-term' buffer."
    :type 'symbol
    :group 'multi-term)

  (defcustom term-unbind-key-list
    '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
    "The key list that will need to be unbind."
    :type 'list
    :group 'multi-term)

  (defcustom term-bind-key-alist
    '(
      ("C-c C-c" . term-interrupt-subjob)
      ("C-c C-e" . term-send-esc)
      ("C-p" . previous-line)
      ("C-n" . next-line)
      ("C-s" . isearch-forward)
      ("C-r" . isearch-backward)
      ("C-m" . term-send-return)
      ("C-y" . term-paste)
      ("M-f" . term-send-forward-word)
      ("M-b" . term-send-backward-word)
      ("M-o" . term-send-backspace)
      ("M-p" . term-send-up)
      ("M-n" . term-send-down)
      ("M-M" . term-send-forward-kill-word)
      ("M-N" . term-send-backward-kill-word)
      ("<C-backspace>" . term-send-backward-kill-word)
      ("M-r" . term-send-reverse-search-history)
      ("M-," . term-send-raw)
      ("M-." . comint-dynamic-complete))
    "The key alist that will need to be bind.
  If you do not like default setup, modify it, with (KEY . COMMAND) format."
    :type 'alist
    :group 'multi-term)

  (defcustom multi-term-dedicated-window-height 14
    "The height of `multi-term' dedicated window."
    :type 'integer
    :group 'multi-term)

  (defcustom multi-term-dedicated-max-window-height 30
    "The max height limit of `multi-term' dedicated window.
  Default, when hide `multi-term' dedicated window, will remember
  window height before hide, except height is larger than this.`"
    :type 'integer
    :group 'multi-term)

  (defcustom multi-term-dedicated-skip-other-window-p nil
    "Default, can have `other-window' select window in cyclic ordering of windows.
  In cases you don't want to select `multi-term' dedicated window, use `other-window'
  and make `multi-term' dedicated window as a viewable sidebar.

  So please turn on this option if you want to skip `multi-term' dedicated window with `other-window'.

  Default is nil."
    :type 'boolean
    :set (lambda (symbol value)
           (set symbol value)
           ;; ad-advised-definition-p no longer exists on Emacs 24.4 as of 2014-01-03.
           (when (fboundp 'multi-term-dedicated-handle-other-window-advice)
             (if (fboundp 'ad-advised-definition-p)
                 (when (ad-advised-definition-p 'other-window)
                   (multi-term-dedicated-handle-other-window-advice value))
               (when (ad-is-advised 'other-window)
                 (multi-term-dedicated-handle-other-window-advice value)))))
    :group 'multi-term)

  (defcustom multi-term-dedicated-select-after-open-p nil
    "Default, multi-term won't focus terminal window after you open dedicated window.
  Please make this option with t if you want focus terminal window.

  Default is nil."
    :type 'boolean
    :group 'multi-term)

  (defcustom multi-term-dedicated-close-back-to-open-buffer-p nil
    "Some userlike the cursor return to the position it was before I opened the dedicated terminal window.
  Please make this option with t if you want it. ;)

  Default is nil."
    :type 'boolean
    :group 'multi-term
    )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Constant ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defconst multi-term-dedicated-buffer-name "MULTI-TERM-DEDICATED"
    "The buffer name of dedicated `multi-term'.")

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variable ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defvar multi-term-dedicated-window nil
    "The dedicated `multi-term' window.")

  (defvar multi-term-dedicated-buffer nil
    "The dedicated `multi-term' buffer.")

  (defvar multi-term-dedicated-close-buffer nil
    "The buffer that first time open dedicated `multi-term' buffer.
  Details look option `multi-term-dedicated-close-back-to-open-buffer-p'.")

  (defvar multi-term-buffer-list nil
    "The list of non-dedicated terminal buffers managed by `multi-term'.")

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Interactive Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;;###autoload
  (defun multi-term ()
    "Create new term buffer.
  Will prompt you shell name when you type `C-u' before this command."
    (interactive)
    (let (term-buffer)
      ;; Set buffer.
      (setq term-buffer (multi-term-get-buffer current-prefix-arg))
      (setq multi-term-buffer-list (nconc multi-term-buffer-list (list term-buffer)))
      (set-buffer term-buffer)
      ;; Internal handle for `multi-term' buffer.
      (multi-term-internal)
      ;; Switch buffer
      (switch-to-buffer term-buffer)))

  ;;;###autoload
  (defun multi-term-next (&optional offset)
    "Go to the next term buffer.
  If OFFSET is `non-nil', will goto next term buffer with OFFSET."
    (interactive "P")
    (multi-term-switch 'NEXT (or offset 1)))

  ;;;###autoload
  (defun multi-term-prev (&optional offset)
    "Go to the previous term buffer.
  If OFFSET is `non-nil', will goto previous term buffer with OFFSET."
    (interactive "P")
    (multi-term-switch 'PREVIOUS (or offset 1)))

  ;;;###autoload
  (defun multi-term-dedicated-open ()
    "Open dedicated `multi-term' window.
  Will prompt you shell name when you type `C-u' before this command."
    (interactive)
    (if (not (multi-term-dedicated-exist-p))
        (let ((current-window (selected-window)))
          (if (multi-term-buffer-exist-p multi-term-dedicated-buffer)
              (unless (multi-term-window-exist-p multi-term-dedicated-window)
                (multi-term-dedicated-get-window))
            ;; Set buffer.
            (setq multi-term-dedicated-buffer (multi-term-get-buffer current-prefix-arg t))
            (set-buffer (multi-term-dedicated-get-buffer-name))
            ;; Get dedicate window.
            (multi-term-dedicated-get-window)
            ;; Whether skip `other-window'.
            (multi-term-dedicated-handle-other-window-advice multi-term-dedicated-skip-other-window-p)
            ;; Internal handle for `multi-term' buffer.
            (multi-term-internal))
          (set-window-buffer multi-term-dedicated-window (get-buffer (multi-term-dedicated-get-buffer-name)))
          (set-window-dedicated-p multi-term-dedicated-window t)
          ;; Select window.
          (select-window
           (if multi-term-dedicated-select-after-open-p
               ;; Focus dedicated terminal window if option `multi-term-dedicated-select-after-open-p' is enable.
               multi-term-dedicated-window
             ;; Otherwise focus current window.
             current-window)))
      (message "`multi-term' dedicated window has exist.")))

  (defun multi-term-dedicated-close ()
    "Close dedicated `multi-term' window."
    (interactive)
    (if (multi-term-dedicated-exist-p)
        (let ((current-window (selected-window)))
          ;; Remember height.
          (multi-term-dedicated-select)
          (multi-term-dedicated-remember-window-height)
          ;; Close window.
          (if (and (require 'ecb nil t)
                   ecb-activated-window-configuration)
              ;; Toggle ECB window when ECB window activated.
              (progn
                (ecb-deactivate)
                (ecb-activate))
            ;; Otherwise delete dedicated window.
            (delete-window multi-term-dedicated-window)
            (if (multi-term-window-exist-p current-window)
                (select-window current-window))))
      (message "`multi-term' window is not exist.")))

  (defun multi-term-dedicated-remember-window-height ()
    "Remember window height."
    (let ((win-height (multi-term-current-window-take-height)))
      (if (and (multi-term-dedicated-window-p) ;in `multi-term' window
               (> win-height 1)
               (<= win-height multi-term-dedicated-max-window-height))
          (setq multi-term-dedicated-window-height win-height))))

  ;;;###autoload
  (defun multi-term-dedicated-toggle ()
    "Toggle dedicated `multi-term' window."
    (interactive)
    (if (multi-term-dedicated-exist-p)
        (progn
          (multi-term-dedicated-close)
          (if (and multi-term-dedicated-close-back-to-open-buffer-p
                   multi-term-dedicated-close-buffer)
              (switch-to-buffer multi-term-dedicated-close-buffer)
            ))
      (if multi-term-dedicated-close-back-to-open-buffer-p
          (setq multi-term-dedicated-close-buffer (current-buffer)))
      (multi-term-dedicated-open)
      ))

  ;;;###autoload
  (defun multi-term-dedicated-select ()
    "Select the `multi-term' dedicated window."
    (interactive)
    (if (multi-term-dedicated-exist-p)
        (select-window multi-term-dedicated-window)
      (message "`multi-term' window is not exist.")))

  (defun term-send-esc ()
    "Send ESC in term mode."
    (interactive)
    (term-send-raw-string "\e"))

  (defun term-send-return ()
    "Use term-send-raw-string \"\C-m\" instead term-send-input.
  Because term-send-input have bug that will duplicate input when you C-a and C-m in terminal."
    (interactive)
    (term-send-raw-string "\C-m")
    )

  (defun term-send-backward-kill-word ()
    "Backward kill word in term mode."
    (interactive)
    (term-send-raw-string "\C-w"))

  (defun term-send-forward-kill-word ()
    "Kill word in term mode."
    (interactive)
    (term-send-raw-string "\ed"))

  (defun term-send-backward-word ()
    "Move backward word in term mode."
    (interactive)
    (term-send-raw-string "\eb"))

  (defun term-send-forward-word ()
    "Move forward word in term mode."
    (interactive)
    (term-send-raw-string "\ef"))

  (defun term-send-reverse-search-history ()
    "Search history reverse."
    (interactive)
    (term-send-raw-string "\C-r"))

  (defun term-send-quote ()
    "Quote the next character in term-mode.
  Similar to how `quoted-insert' works in a regular buffer."
    (interactive)
    (term-send-raw-string "\C-v"))

  (defun term-send-M-x ()
    "Type M-x in term-mode."
    (interactive)
    (term-send-raw-string "\ex"))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilise Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun multi-term-internal ()
    "Internal handle for `multi-term' buffer."
    ;; Add customize keystroke with `term-mode-hook'
    (remove-hook 'term-mode-hook 'multi-term-keystroke-setup)
    (add-hook 'term-mode-hook 'multi-term-keystroke-setup)
    ;; Load term mode
    (term-mode)
    (term-char-mode)
    ;; Handle term buffer close
    (multi-term-handle-close)
    ;; Handle `output' variable.
    (setq term-scroll-show-maximum-output multi-term-scroll-show-maximum-output
          term-scroll-to-bottom-on-output multi-term-scroll-to-bottom-on-output)
    ;; Add hook to be sure `term' quit subjob before buffer killed.
    (add-hook 'kill-buffer-hook 'multi-term-kill-buffer-hook))

  (defun multi-term-get-buffer (&optional special-shell dedicated-window)
    "Get term buffer.
  If option SPECIAL-SHELL is `non-nil', will use shell from user input.
  If option DEDICATED-WINDOW is `non-nil' will create dedicated `multi-term' window ."
    (with-temp-buffer
      (let ((shell-name (or multi-term-program ;shell name
                            (getenv "SHELL")
                            (getenv "ESHELL")
                            "/bin/sh"))
            (index 1)                     ;setup new term index
            term-name)                    ;term name
        (if dedicated-window
            (setq term-name multi-term-dedicated-buffer-name)
          ;; Compute index.
          (while (buffer-live-p (get-buffer (format "*%s<%s>*" multi-term-buffer-name index)))
            (setq index (1+ index)))
          ;; switch to current local directory,
          ;; if in-existence, switch to `multi-term-default-dir'.
          (cd (or default-directory (expand-file-name multi-term-default-dir)))
          ;; adjust value N when max index of term buffer is less than length of term list
          (setq term-name (format "%s<%s>" multi-term-buffer-name index)))
        ;; Try get other shell name if `special-shell' is non-nil.
        (if special-shell
            (setq shell-name (read-from-minibuffer "Run program: " shell-name)))
        ;; Make term, details to see function `make-term' in `term.el'.
        (if multi-term-program-switches
            (make-term term-name shell-name nil multi-term-program-switches)
          (make-term term-name shell-name)))))


  (defun multi-term-handle-close ()
    "Close current term buffer when `exit' from term buffer."
    (when (ignore-errors (get-buffer-process (current-buffer)))
      (set-process-sentinel (get-buffer-process (current-buffer))
                            (lambda (proc change)
                              (when (string-match "\\(finished\\|exited\\)" change)
                                (kill-buffer (process-buffer proc)))))))

  (defun multi-term-kill-buffer-hook ()
    "Function that hook `kill-buffer-hook'."
    (when (eq major-mode 'term-mode)
      ;; Quit the current subjob
      ;; when have alive process with current term buffer.
      ;; Must do this job BEFORE `multi-term-switch-after-close' action.
      (when (term-check-proc (current-buffer))
        ;; Quit sub-process.
        (term-quit-subjob))
      ;; Remember dedicated window height.
      (multi-term-dedicated-remember-window-height)
      (let ((killed-buffer (current-buffer)))
        ;; Try to switch other multi-term buffer
        ;; when option `multi-term-switch-after-close' is non-nil.
        (when multi-term-switch-after-close
          (multi-term-switch-internal multi-term-switch-after-close 1))
        ;; Remove killed buffer from the buffer list if it's in there
        (setq multi-term-buffer-list
              (delq killed-buffer multi-term-buffer-list)))))

  (defun multi-term-switch (direction offset)
    "Switch `multi-term' buffers.
  If DIRECTION is `NEXT', switch to the next term.
  If DIRECTION `PREVIOUS', switch to the previous term.
  Option OFFSET for skip OFFSET number term buffer."
    (unless (multi-term-switch-internal direction offset)
      (if multi-term-try-create
          (progn
            (multi-term)
            (message "Created a new `multi-term' buffer."))
        (message "No `multi-term' buffers exist."))))

  (defun multi-term-switch-internal (direction offset)
    "Internal `multi-term' buffers switch function.
  If DIRECTION is `NEXT', switch to the next term.
  If DIRECTION `PREVIOUS', switch to the previous term.
  Option OFFSET for skip OFFSET number term buffer."
    (if multi-term-buffer-list
        (let ((buffer-list-len (length multi-term-buffer-list))
              (my-index (position (current-buffer) multi-term-buffer-list)))
          (if my-index
              (let ((target-index (if (eq direction 'NEXT)
                                      (mod (+ my-index offset) buffer-list-len)
                                    (mod (- my-index offset) buffer-list-len))))
                (switch-to-buffer (nth target-index multi-term-buffer-list)))
            (switch-to-buffer (car multi-term-buffer-list))))
      nil))

  (defun multi-term-keystroke-setup ()
    "Keystroke setup of `term-char-mode'.

  By default, the key bindings of `term-char-mode' conflict with user's keystroke.
  So this function unbinds some keys with `term-raw-map',
  and binds some keystroke with `term-raw-map'."
    (let (bind-key bind-command)
      ;; Unbind base key that conflict with user's keys-tokes.
      (dolist (unbind-key term-unbind-key-list)
        (cond
         ((stringp unbind-key) (setq unbind-key (read-kbd-macro unbind-key)))
         ((vectorp unbind-key) nil)
         (t (signal 'wrong-type-argument (list 'array unbind-key))))
        (define-key term-raw-map unbind-key nil))
      ;; Add some i use keys.
      ;; If you don't like my keystroke,
      ;; just modified `term-bind-key-alist'
      (dolist (element term-bind-key-alist)
        (setq bind-key (car element))
        (setq bind-command (cdr element))
        (cond
         ((stringp bind-key) (setq bind-key (read-kbd-macro bind-key)))
         ((vectorp bind-key) nil)
         (t (signal 'wrong-type-argument (list 'array bind-key))))
        (define-key term-raw-map bind-key bind-command))))

  (defun multi-term-dedicated-handle-other-window-advice (activate)
    "Handle advice for function `other-window'.
  If ACTIVATE is `non-nil', will enable advice
  `multi-term-dedicated-other-window-advice'.
  Otherwise, disable it."
    (if activate
        (ad-enable-advice 'other-window 'after 'multi-term-dedicated-other-window-advice)
      (ad-disable-advice 'other-window 'after 'multi-term-dedicated-other-window-advice))
    (ad-activate 'other-window))

  (defun multi-term-current-window-take-height (&optional window)
    "Return the height the `window' takes up.
  Not the value of `window-height', it returns usable rows available for WINDOW.
  If `window' is nil, get current window."
    (let ((edges (window-edges window)))
      (- (nth 3 edges) (nth 1 edges))))

  (defun multi-term-dedicated-get-window ()
    "Get `multi-term' dedicated window."
    (setq multi-term-dedicated-window
          (split-window
           (selected-window)
           (- (multi-term-current-window-take-height) multi-term-dedicated-window-height))))

  (defun multi-term-dedicated-get-buffer-name ()
    "Get the buffer name of `multi-term' dedicated window."
    (format "*%s*" multi-term-dedicated-buffer-name))

  (defun multi-term-dedicated-exist-p ()
    "Return `non-nil' if `multi-term' dedicated window exist."
    (and (multi-term-buffer-exist-p multi-term-dedicated-buffer)
         (multi-term-window-exist-p multi-term-dedicated-window)))

  (defun multi-term-window-exist-p (window)
    "Return `non-nil' if WINDOW exist.
  Otherwise return nil."
    (and window (window-live-p window)))

  (defun multi-term-buffer-exist-p (buffer)
    "Return `non-nil' if `BUFFER' exist.
  Otherwise return nil."
    (and buffer (buffer-live-p buffer)))

  (defun multi-term-dedicated-window-p ()
    "Return `non-nil' if current window is `multi-term' dedicated window.
  Otherwise return nil."
    (equal (multi-term-dedicated-get-buffer-name) (buffer-name (window-buffer))))

  (defun multi-term-window-dedicated-only-one-p ()
    "Only have one non-dedicated window."
    (interactive)
    (let ((window-number 0)
          (dedicated-window-number 0))
      (walk-windows
       (lambda (w)
         (with-selected-window w
           (incf window-number)
           (if (window-dedicated-p w)
               (incf dedicated-window-number)))))
      (if (and (> dedicated-window-number 0)
               (= (- window-number dedicated-window-number) 1))
          t nil)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Advice ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defadvice delete-other-windows (around multi-term-delete-other-window-advice activate)
    "This is advice to make `multi-term' avoid dedicated window deleted.
  Dedicated window can't deleted by command `delete-other-windows'."
    (let ((multi-term-dedicated-active-p (multi-term-window-exist-p multi-term-dedicated-window)))
      (if multi-term-dedicated-active-p
          (let ((current-window (selected-window)))
            (dolist (win (window-list))
              (when (and (window-live-p win)
                         (not (eq current-window win))
                         (not (window-dedicated-p win)))
                (delete-window win))))
        ad-do-it)))

  (defadvice delete-window (before multi-term-delete-window-advice activate)
    "Use `delete-window' delete `multi-term' dedicated window.
  Have same effect as command `multi-term-dedicated-close'.
  This advice to remember `multi-term' dedicated window height before deleting."
    ;; Remember window height before deleted.
    (multi-term-dedicated-remember-window-height))

  (defadvice pop-to-buffer (before multi-term-pop-to-buffer-advice activate)
    "This advice fix the problem between `pop-to-buffer' and dedicated window.
  By default, function `display-buffer' can't display buffer in selected window
  if current window is `dedicated'.

  So function `display-buffer' conflicts with `sr-speedbar' window, because
  `sr-speedbar' window is a `dedicated' window.

  That is to say, when current frame just have one `non-dedicated' window,
  any functions that uses `display-buffer' can't split windows
  to display buffer, even when the option `pop-up-windows' is enabled.

  And the example function that can induce the problem is `pop-to-buffer'.

  This advice will fix this problem when current frame just have one `non-dedicated' window."
    (when (and pop-up-windows                           ;`pop-up-windows' is enable
               (multi-term-window-dedicated-only-one-p) ;just have one `non-dedicated' window.
               (multi-term-window-exist-p multi-term-dedicated-window)
               (not (multi-term-dedicated-window-p))) ;not in `sr-speedbar' window
      (split-window-vertically)
      (windmove-down)))

  (defadvice other-window (after multi-term-dedicated-other-window-advice)
    "Default, can use `other-window' select window in cyclic ordering of windows.
  But sometimes we don't want to select `sr-speedbar' window,
  but use `other-window' and just make `multi-term' dedicated
  window as a viewable sidebar.

  This advice can make `other-window' skip `multi-term' dedicated window."
    (let ((count (or (ad-get-arg 0) 1)))
      (when (and (multi-term-window-exist-p multi-term-dedicated-window)
                 (eq multi-term-dedicated-window (selected-window)))
        (other-window count))))

  (provide 'multi-term)

  ;; Local Variables:
  ;; time-stamp-line-limit: 10
  ;; time-stamp-start: "Last-Updated: <"
  ;; time-stamp-end: ">"
  ;; End:

  ;;; multi-term.el ends here

  ;;; LocalWords:  multi el dir sr Hawley eb ef cd
#+end_src

#+begin_src emacs-lisp
(setq multi-term-program "/bin/zsh")
#+end_src

** TODO God Mode

[[https://github.com/chrisdone/god-mode][God Mode]] is a global minor mode for entering Emacs commands without modifier
keys. It's similar to Vim's separation of commands and insertion mode.

Activate for all future buffers by running =M-x god-mode=. Although the activation
is buffer-local.

#+begin_src emacs-lisp :tangle no
  (use-package god-mode
    :ensure t
    :config
    ;; Toggle between God mode and non-God mode using ESC:
    (global-set-key (kbd "<escape>") 'god-local-mode)
    ;; If you want to enable/disable on all active and future buffers, use this:
    ;; (global-set-key (kbd "<escape>") 'god-mode-all)

    ;; If you are using the global mode, you might want to make no buffers exempt:
    ;; This means that e.g. magit-mode or dired-mode will also enter
    ;; god-mode when you activate it globally, and vise-verse. It means
    ;; you can always reliably use god-mode commands in any buffer as
    ;; long as it is globally activated.
    (setq god-exempt-major-modes nil)
    (setq god-exempt-predicates nil)

    (define-key god-local-mode-map (kbd "i") 'god-local-mode)
    ;; Error (use-package): god-mode :init: Symbol's value as variable is void: god-local-mode-map
    (global-set-key (kbd "C-x C-1") 'delete-other-windows)
    (global-set-key (kbd "C-x C-2") 'split-window-below)
    (global-set-key (kbd "C-x C-3") 'split-window-right)
    (global-set-key (kbd "C-x C-0") 'delete-window))
#+end_src

Also, you can add this to your .xmodmap to rebind Caps Lock to Escape:
#+BEGIN_SRC conf :tangle no ~/.xmodmap
clear lock
clear control
add control = Caps_Lock Control_L Control_R
#+END_SRC

*** TODO Cursor style to indicate mode
You can change the cursor style indicate whether you're in God mode or not.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun jhaus/update-cursor ()
    (setq cursor-type (if (or god-local-mode buffer-read-only)
                          'hbar
                        'box)))

  (add-hook 'god-mode-enabled-hook 'jhaus/update-cursor)
  (add-hook 'god-mode-disabled-hook 'jhaus/update-cursor)
#+end_src

*** TODO Timer
WTF! This runs like 12 times. Even with repeat as nil.

Don't allow just hanging out in god mode. You have n sec to execute a
command in god-mode.

#+begin_src emacs-lisp :tangle no
  (defun jhaus/god-mode-timeout ()
    "kill god-mode n sec after entering"
    ;; TODO: debounce by canceling old timer.
    (run-at-time "5 sec" nil 'message "god timer is broken!!!"))

  (add-hook 'god-mode-enabled-hook 'jhaus/god-mode-timeout)


#+end_src

*** TODO Change modeline color
You can use the following function to switch the entire modeline's foreground
and background:

#+BEGIN_SRC emacs-lisp :tangle no
  (defun jhaus/god-mode-update-modeline ()
    (let ((limited-colors-p (> 257 (length (defined-colors)))))
      (cond (god-local-mode (progn
                              (set-face-background 'mode-line (if limited-colors-p "white" "black"))
                              (set-face-background 'mode-line-inactive (if limited-colors-p "black" "#1a1a1a"))))
            (t (progn
                 (set-face-background 'mode-line (if limited-colors-p "black" "gray30"))
                 (set-face-background 'mode-line-inactive (if limited-colors-p "black" "#1a1a1a")))))))

  (add-hook 'god-mode-enabled-hook 'jhaus/god-mode-update-modeline)
  (add-hook 'god-mode-disabled-hook 'jhaus/god-mode-update-modeline)
#+END_SRC

*** TODO change background color
I never notice when I'm in command mode. Just like vim I destroy my buffer by typing.

May need something more extreme like =(shell-command xcalib -invert -alter)=.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun jhaus/god-mode-change-background ()
    (let ((limited-colors-p (> 257 (length (defined-colors)))))
      (cond (god-local-mode
             (set-background-color (if limited-colors-p "dim-gray" "gray25")))
            (t
             (set-background-color (if limited-colors-p "black" "#272822"))))))

  (add-hook 'god-mode-enabled-hook 'jhaus/god-mode-change-background)
  (add-hook 'god-mode-disabled-hook 'jhaus/god-mode-change-background)
#+END_SRC

*** TODO change colors via xcalib
Extreme circumstances call for extreme measures!

#+begin_src emacs-lisp :tangle no
  (defun jhaus/god-mode-xcalib ()
    (if god-local-mode
        (shell-command "xcalib -invert -alter")
      (shell-command "xcalib -clear")))

  (add-hook 'god-mode-enabled-hook 'jhaus/god-mode-xcalib)
  (add-hook 'god-mode-disabled-hook 'jhaus/god-mode-xcalib)

#+end_src

*** TODO Overwrite mode
You can pause god-mode when overwrite-mode is enabled and resume when
overwrite-mode is disabled.

#+BEGIN_SRC emacs-lisp :tangle no
(defun god-toggle-on-overwrite ()
  "Toggle god-mode on overwrite-mode."
  (if (bound-and-true-p overwrite-mode)
      (god-local-mode-pause)
    (god-local-mode-resume)))

(add-hook 'overwrite-mode-hook 'god-toggle-on-overwrite)
#+END_SRC

*** TODO isearch integration
There is a small module for providing god-mode-like behaviour for isearch: You can hit while in isearch, for example:

=s hello <escape> s s s RET=

For

=C-s hello C-s C-s C-s RET=

#+begin_src emacs-lisp :tangle no
  (require 'god-mode-isearch)
  (define-key isearch-mode-map (kbd "<escape>") 'god-mode-isearch-activate)
  (define-key god-mode-isearch-map (kbd "<escape>") 'god-mode-isearch-disable)

#+end_src

** TODO flatland-theme
I loved this theme in sublime. Looks like it being actively maintained for emacs
by [[https://github.com/gchp/flatland-emacs][gchp]]. My thanks.

#+begin_src emacs-lisp :tangle no
  (use-package flatland-theme
    :defer t
    :ensure t)
#+END_src

** TODO speed-type

[[./img/speed-type.png]]

[[https://github.com/hagleitn/speed-type][speed-type]] is for practice touch/speed typing in Emacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package speed-type
    :ensure t
    :defer t)
#+END_SRC

** TODO fill-column-indicator
This wasn't working properly, but more importantly, Do we care?
Hetinger says each line of code contains a single idea. The hobgoblin
of little minds.

[[https://github.com/alpaker/Fill-Column-Indicator][fill-column-indicator]] toggle the vertical column that indicates the fill
threshold.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package fill-column-indicator
    :ensure t
    :commands fci-mode
    :config
    (fci-mode)
    (setq fci-rule-column 79))
#+END_SRC

** Spaceline
the Spacemacs mode-line. https://github.com/TheBB/spaceline

#+begin_src emacs-lisp :tangle no
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
    (setq powerline-height 24)
   ;(spaceline-emacs-theme)
    (powerline-default-theme)
    )
#+end_src

** TODO idle-highlight-mode
Recommended by the Starter Kit

https://github.com/nonsequitur/idle-highlight-mode
#+begin_src emacs-lisp :tangle no
  (use-package idle-highlight-mode
    :ensure t
    :config
    (custom-set-faces
      '(idle-highlight ((t (:background "gray26"))))))
#+end_src

** TODO pos-tip
Causing a SEGFAULT on arch linux?

A utility function for displaying the tooltip at arbitrary locations.

#+begin_src emacs-lisp :tangle no
  (use-package pos-tip
    :ensure t)
#+end_src

** Smart-mode-line
put the following line in the respectful theme:  ;;'(sml/global    ((t :foreground "gray50" :inverse-video nil)))

#+begin_src emacs-lisp :tangle no
   (use-package smart-mode-line
     :ensure t
     :config
     (setq sml/theme 'respectful)
     (sml/setup))
#+end_src
** TODO find-file-in-project
=counsel-git= replaces this.

https://github.com/technomancy/find-file-in-project

Ivy-mode is a dependency.

#+begin_src emacs-lisp :tangle no
  (use-package find-file-in-project
    :ensure t
    :config
    (progn
      (setq ffip-prefer-ido-mode t)
      (setq-local ffip-filename-rules
              '(ffip-filename-identity
                ffip-filename-dashes-to-camelcase
                ffip-filename-camelcase-to-dashes))))

#+end_src

** Ido
*** smex
[[https://github.com/nonsequitur/smex][Smex]] is a M-x enhancement for Emacs. Built on top of IDO, it provides
a convenient interface to your recently and most frequently used
commands. And to all the other commands, too.

| Binding | Call                     | Do                                                           |
|---------+--------------------------+--------------------------------------------------------------|
| M-x     | smex                     | Calls a interactive command using smex                       |
| M-X     | smex-major-mode-commands | Idem as above but limited to the current major mode commands |

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smex
    :ensure t
    :init
    (bind-key "<menu>" 'smex)
    :config
    (setq smex-prompt-string "M-x "))
#+END_SRC

**** Useful bindings & Delayed Initation

#+BEGIN_QUOTE
I install smex with the following code to make emacs startup a little
faster.  This delays initializing smex until it's needed. IMO, smex
should load without this hack.

Just have smex call =smex-initialize= when it's needed instead of
having the user do it. --[[http://www.emacswiki.org/emacs/Smex][LeWang on EmacsWiki]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key [(meta x)] (lambda ()
                               (interactive)
                               (or (boundp 'smex-cache)
                                  (smex-initialize))
                               (global-set-key [(meta x)] 'smex)
                               (smex)))

  (global-set-key [(shift meta x)] (lambda ()
                                     (interactive)
                                     (or (boundp 'smex-cache)
                                        (smex-initialize))
                                     (global-set-key [(shift meta x)] 'smex-major-mode-commands)
                                     (smex-major-mode-commands)))
(global-set-key (kbd "C-'") 'smex)
#+END_SRC

*** ido
Use ido to deal with files and buffers in a more pleasant way.

#+BEGIN_SRC emacs-lisp :tangle no
    (use-package ido
      :config
      (setq
       ido-enable-flex-matching t
       ;; remember visited files
       ido-use-virtual-buffers t
       ;; allow opening an already opened buffer in new frame with C-x b
       ido-default-buffer-method 'selected-window)
      ;; (setq
      ;;  ido-save-directory-list-file
      ;;  (concat joe-emacs-temporal-directory "ido.last"))
      (ido-mode t)
      (ido-everywhere t)
      )
#+END_SRC

*** ido-ubiquitous

Gimme some ido... everywhere!

[[https://github.com/DarwinAwardWinner/ido-ubiquitous][ido-ubiquitous]] does what you were really hoping for when you did =(setq ido-everywhere
t)=. Replaces stock emacs completion with ido completion wherever it is possible
to do so without breaking things.

#+BEGIN_SRC emacs-lisp :tangle no
    (use-package ido-ubiquitous
      :ensure t
      :disabled t
      :ensure ido
      :config
      (setq org-completion-use-ido t)
      (setq magit-completing-read-function 'magit-ido-completing-read)
      (ido-ubiquitous-mode t)
      (setq ido-ubiquitous-max-items 50000))
#+END_SRC

*** ido-vertical-mode
[[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertical-mode]] makes =ido-mode= display vertically.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido-vertical-mode
    :ensure t
    :ensure ido
    :config
    (ido-vertical-mode t)
    (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right))
#+END_SRC

*** ido-hacks
Adds some nifty functionality that I thought was default ido. It isn't. I'll
update this text when I figure out exactly what is done here.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido-hacks
    :ensure t
    :ensure ido)
#+END_SRC
** TODO twittering-mode
- pgp key not authenticating

[[https://github.com/hayamiz/twittering-mode][Twittering-mode]] enables you to twit on Emacsen.

[[./img/twittering_mode.png]]


#+BEGIN_SRC emacs-lisp :tangle no
    (use-package twittering-mode
      :ensure t
      :commands twit
      :init
      (add-hook 'twittering-edit-mode-hook (lambda () (flyspell-mode)))
      (add-hook 'twittering-mode-hook (lambda () (variable-pitch-mode)))
      :config
      (setq twittering-use-master-password t
            twittering-icon-mode t
            twittering-use-icon-storage t
            twittering-convert-fix-size 52
            twittering-initial-timeline-spec-string '(":home")
            twittering-edit-skeleton 'inherit-any
            twittering-display-remaining t
            twittering-timeline-header  "─────────────────────────────────────────────────────────────────────────────\n"
            twittering-timeline-footer  "─────────────────────────────────────────────────────────────────────────────\n"
            twittering-status-format
            "%i  %S, %RT{%FACE[bold]{%S}} %@  %FACE[shadow]{%p%f%L%r}\n%FOLD[             ]{%T}\n")

        ;; set the new bindings
  ;;      (bind-keys :map twittering-mode-map
  ;;                 ("q" . twittering-kill-buffer)
  ;;                 ("Q" . twittering-edit-mode)
  ;;                 ("n" . twittering-goto-next-status)
  ;;                 ("e" . twittering-goto-previous-status)
  ;;                 ("h" . twittering-switch-to-next-timeline)
  ;;                 ("i" . twittering-switch-to-previous-timeline)
  ;;                 ("g" . beginning-of-buffer)
  ;;                 ("G" . end-of-buffer)
  ;;                 ("t" . twittering-update-status-interactive)
  ;;                 ("X" . twittering-delete-status)
  ;;                 ("RET" . twittering-reply-to-user)
  ;;                 ("r" . twittering-native-retweet)
  ;;                 ("R" . twittering-organic-retweet)
  ;;                 ("d" . twittering-direct-message)
  ;;                 ("c" . twittering-current-timeline)
  ;;                 ("b" . twittering-favorite)
  ;;                 ("B" . twittering-unfavorite)
  ;;                 ("f" . twittering-follow)
  ;;                 ("F" . twittering-unfollow)
  ;;                 ("u" . twittering-view-user-page)
  ;;                 ("/" . twittering-search)
  ;;                 ("." . twittering-visit-timeline)
  ;;                 ("@" . twittering-other-user-timeline)
  ;;                 ("T" . twittering-toggle-or-retrieve-replied-statuses)
  ;;                 ("o" . twittering-click)
  ;;                 ("TAB" . twittering-goto-next-thing)
  ;;                 ("<backtab>" . twittering-goto-previous-thing)
  ;;                 ("N" . twittering-goto-next-status-of-user)
  ;;                 ("E" . twittering-goto-previous-status-of-user)
  ;;                 ("SPC" . twittering-scroll-up)
  ;;                 ("S-SPC" . twittering-scroll-down)
  ;;                 ("y" . twittering-push-uri-onto-kill-ring)
  ;;                 ("Y" . twittering-push-tweet-onto-kill-ring)
  ;;                 ("a" . twittering-toggle-activate-buffer))
  )
#+END_SRC
** GNUS
https://www.quora.com/Is-it-worth-learning-gnus-for-emacs

https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org

http://stackoverflow.com/questions/20979918/reading-email-from-gmail-in-emacs-24#20982154

#+begin_src emacs-lisp :tangle no
;; nothing here
#+end_src
** TODO Wanderlust

#+begin_src emacs-lisp :tangle no


;; IMAP, gmail:
(setq elmo-imap4-default-server "imap.gmail.com"
      elmo-imap4-default-user "jesse.haubrich@gmail.com"
      elmo-imap4-default-authenticate-type 'clear
      elmo-imap4-default-port '993
      elmo-imap4-default-stream-type 'ssl

      ;; For non ascii-characters in folder-names
      elmo-imap4-use-modified-utf7 t)

;; SMTP
(setq wl-smtp-connection-type 'starttls
      wl-smtp-posting-port 587
      wl-smtp-authenticate-type "plain"
      wl-smtp-posting-user "myname"
      wl-smtp-posting-server "smtp.gmail.com"
      wl-local-domain "gmail.com"
      wl-message-id-domain "smtp.gmail.com")

(setq wl-from "Jesse Haubrich <jesse.haubrich@gmail.com>"

      ;; All system folders (draft, trash, spam, etc) are placed in the
      ;; [Gmail]-folder, except inbox. "%" means it's an IMAP-folder
      wl-default-folder "%inbox"
      wl-draft-folder   "%[Gmail]/Drafts"
      wl-trash-folder   "%[Gmail]/Trash"
      ;; The below is not necessary when you send mail through Gmail's SMTP server,
      ;; see https://support.google.com/mail/answer/78892?hl=en&rd=1
      ;; wl-fcc            "%[Gmail]/Sent"

      ;; Mark sent messages as read (sent messages get sent back to you and
      ;; placed in the folder specified by wl-fcc)
      wl-fcc-force-as-read    t

      ;; For auto-completing foldernames
      wl-default-spec "%")


#+end_src
